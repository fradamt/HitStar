<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#1a1a2e">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>HitStar - Spotify Edition</title>
<link rel="manifest" href="manifest.json">
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #0c0c14;
  --surface: #17171f;
  --surface2: #222230;
  --accent: #1db954;
  --accent-hover: #1ed760;
  --text: #ffffff;
  --text-dim: #b3b3b3;
  --danger: #e74c3c;
  --card-bg: #1c1c2a;
}
html, body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  overflow-x: hidden;
}
.screen { display: none; min-height: 100vh; padding: 16px; padding-bottom: 80px; }
.screen.active { display: flex; flex-direction: column; }
.nav {
  position: fixed; bottom: 0; left: 0; right: 0;
  background: var(--surface); border-top: 1px solid #333;
  display: flex; z-index: 100; padding-bottom: env(safe-area-inset-bottom);
}
.nav button {
  flex: 1; background: none; border: none; color: var(--text-dim);
  padding: 10px 4px; font-size: 11px; cursor: pointer;
  display: flex; flex-direction: column; align-items: center; gap: 4px;
}
.nav button.active { color: var(--accent); }
.nav button svg { width: 24px; height: 24px; }
h1 { font-size: 22px; margin-bottom: 12px; }
h2 { font-size: 18px; margin-bottom: 10px; color: var(--text-dim); }
.btn {
  display: inline-flex; align-items: center; justify-content: center; gap: 8px;
  background: var(--accent); color: #000; border: none; border-radius: 24px;
  padding: 14px 28px; font-size: 16px; font-weight: 600; cursor: pointer;
  transition: background 0.2s;
}
.btn:hover { background: var(--accent-hover); }
.btn:active { transform: scale(0.97); }
.btn-outline {
  background: transparent; color: var(--accent); border: 2px solid var(--accent);
}
.btn-outline:hover { background: rgba(29,185,84,0.1); color: var(--accent); }
.btn-sm { padding: 8px 18px; font-size: 14px; }
.btn-danger { background: var(--danger); }
.btn-danger:hover { background: #c0392b; }
.btn-block { width: 100%; }

/* HOME */
#home { align-items: center; justify-content: center; gap: 20px; text-align: center; }
#home .logo { font-size: 36px; font-weight: 800; letter-spacing: 2px; }
#home .logo span { color: var(--accent); }
#home .subtitle { color: var(--text-dim); font-size: 14px; margin-bottom: 20px; }
.home-actions { display: flex; flex-direction: column; gap: 14px; width: 100%; max-width: 300px; }
.home-actions .btn { font-size: 18px; padding: 18px; }

/* Connect prompt on home */
.connect-prompt {
  background: var(--surface); border-radius: 16px; padding: 24px; margin-top: 12px;
  width: 100%; max-width: 340px; text-align: center;
}
.connect-prompt p { color: var(--text-dim); font-size: 13px; margin-bottom: 14px; }
.connect-prompt .btn { width: 100%; }
.connect-prompt .setup-fields { margin-top: 14px; text-align: left; }
.connect-prompt .setup-fields label { font-size: 12px; color: var(--text-dim); display: block; margin-bottom: 4px; }
.connect-prompt .setup-fields input { margin-bottom: 10px; }

/* NOW PLAYING */
#now-playing { align-items: center; justify-content: center; gap: 20px; text-align: center; }
.np-card {
  background: var(--card-bg); border-radius: 16px; padding: 30px 20px;
  width: 100%; max-width: 360px;
}
.np-hidden-info { filter: blur(20px); transition: filter 0.5s; user-select: none; }
.np-hidden-info.revealed { filter: none; }
.np-category {
  display: inline-block; background: var(--surface2); padding: 4px 14px;
  border-radius: 12px; font-size: 13px; color: var(--accent); margin-bottom: 14px;
}
.np-artist { font-size: 22px; font-weight: 700; margin-bottom: 6px; }
.np-title { font-size: 16px; color: var(--text-dim); margin-bottom: 16px; }
.np-year {
  font-size: 52px; font-weight: 800; color: var(--accent);
  margin: 10px 0;
}
.np-actions { display: flex; flex-direction: column; gap: 12px; margin-top: 16px; width: 100%; max-width: 360px; }
.np-actions .btn { justify-content: center; }
.reveal-hint { color: var(--text-dim); font-size: 13px; margin-top: 6px; }

/* Custom player controls */
.sdk-player-controls {
  display: flex; align-items: center; gap: 12px; margin: 16px 0 4px;
  width: 100%;
}
.sdk-play-btn {
  background: var(--accent); border: none; border-radius: 50%;
  width: 44px; height: 44px; min-width: 44px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; transition: background 0.2s, transform 0.1s;
}
.sdk-play-btn:hover { background: var(--accent-hover); }
.sdk-play-btn:active { transform: scale(0.93); }
.sdk-play-btn svg { fill: #000; width: 20px; height: 20px; }
.sdk-progress-wrap {
  flex: 1; height: 6px; background: rgba(255,255,255,0.15); border-radius: 3px;
  cursor: pointer; position: relative; overflow: hidden;
}
.sdk-progress-bar {
  height: 100%; background: var(--accent); border-radius: 3px;
  width: 0%; transition: width 0.3s linear;
}
.sdk-player-error {
  color: var(--danger); font-size: 12px; margin-top: 4px; min-height: 16px;
}

/* PLAYLISTS */
#playlists { gap: 14px; }

/* SETTINGS */
#settings { gap: 16px; }
.setting-group { background: var(--surface); border-radius: 12px; padding: 16px; }
.setting-group h3 { font-size: 15px; margin-bottom: 10px; }
.setting-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; }
.setting-row label { color: var(--text-dim); font-size: 14px; }
textarea, input[type="text"], input[type="number"], select {
  background: var(--bg); border: 1px solid #444; border-radius: 8px;
  color: var(--text); padding: 10px; width: 100%; font-size: 14px;
  font-family: inherit;
}
textarea { min-height: 120px; resize: vertical; }
input[type="file"] { display: none; }

/* MODAL */
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.7);
  display: flex; align-items: center; justify-content: center;
  z-index: 200; padding: 20px;
}
.modal-overlay.hidden { display: none; }
.modal {
  background: var(--surface); border-radius: 16px; padding: 24px;
  width: 100%; max-width: 420px; max-height: 80vh; overflow-y: auto;
}
.modal h2 { margin-bottom: 16px; }
.modal .form-group { margin-bottom: 14px; }
.modal .form-group label { display: block; font-size: 13px; color: var(--text-dim); margin-bottom: 4px; }
.modal-actions { display: flex; gap: 10px; margin-top: 18px; }
.modal-actions .btn { flex: 1; }

/* Now Playing - listening state */
.np-listening-icon {
  margin: 20px 0 10px;
  animation: pulse 2s ease-in-out infinite;
}
@keyframes pulse {
  0%, 100% { opacity: 0.6; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.1); }
}

/* Spotify badge */
.spotify-badge {
  display: inline-flex; align-items: center; gap: 6px;
  color: var(--accent); font-size: 13px;
}
.spotify-badge svg { width: 18px; height: 18px; fill: var(--accent); }

/* Toast notification */
.toast {
  position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
  background: var(--surface); border: 1px solid #444; border-radius: 12px;
  padding: 12px 20px; font-size: 14px; z-index: 300;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4); transition: opacity 0.3s;
  max-width: 90vw; text-align: center;
}
.toast.toast-error { border-color: var(--danger); color: var(--danger); }
.toast.toast-success { border-color: var(--accent); color: var(--accent); }
.toast.toast-hidden { opacity: 0; pointer-events: none; }

/* ==================== GAME BOARD ==================== */
#game-board {
  padding: 0; min-height: 100vh; display: none;
  flex-direction: column; overflow: hidden;
}
#game-board.active { display: flex; }

/* Top bar */
.game-topbar {
  display: flex; align-items: center; gap: 10px;
  background: var(--surface); border-bottom: 1px solid #333;
  padding: 8px 14px; height: 48px; flex-shrink: 0; z-index: 10;
}
.game-topbar .sdk-play-btn {
  width: 32px; height: 32px; min-width: 32px;
}
.game-topbar .sdk-play-btn svg { width: 16px; height: 16px; }
.game-topbar .sdk-progress-wrap { flex: 1; height: 4px; }
.game-topbar-status {
  font-size: 13px; font-weight: 600; white-space: nowrap;
  min-width: 0; overflow: hidden; text-overflow: ellipsis;
}
.game-topbar-status.correct { color: var(--accent); }
.game-topbar-status.wrong { color: var(--danger); }
.game-topbar-nowplaying {
  display: flex; align-items: center; gap: 8px;
  flex: 1; min-width: 0; overflow: hidden;
}
.game-topbar-nowplaying-year {
  font-size: 14px; font-weight: 800; color: var(--accent);
  flex-shrink: 0;
}
.game-topbar-nowplaying-text {
  display: flex; flex-direction: column; justify-content: center;
  min-width: 0; line-height: 1.2;
}
.game-topbar-nowplaying-artist {
  font-size: 13px; font-weight: 600; color: var(--text);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.game-topbar-nowplaying-title {
  font-size: 11px; color: var(--text-dim);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.game-topbar-nowplaying.obfuscated .game-topbar-nowplaying-artist,
.game-topbar-nowplaying.obfuscated .game-topbar-nowplaying-title,
.game-topbar-nowplaying.obfuscated .game-topbar-nowplaying-year {
  filter: blur(6px); user-select: none; pointer-events: none;
}
.game-topbar-btn {
  background: none; border: 1px solid #444; border-radius: 8px;
  color: var(--text-dim); font-size: 13px; padding: 4px 10px;
  cursor: pointer; white-space: nowrap;
}
.game-topbar-btn:hover { color: var(--text); border-color: #666; }

/* Game body (player rows) */
.game-body {
  flex: 1; overflow-y: auto; padding: 16px;
  padding-right: calc(var(--piles-sidebar-w, 180px) + 16px);
  display: flex; flex-direction: column; gap: 20px;
}

/* Player colors */
:root {
  --p0: #e74c3c; --p0-dim: rgba(231,76,60,0.15); --p0-glow: rgba(231,76,60,0.35);
  --p1: #3498db; --p1-dim: rgba(52,152,219,0.15); --p1-glow: rgba(52,152,219,0.35);
  --p0-surface: #241a1e; /* warm tinted dark surface for red player */
  --p1-surface: #161d28; /* cool tinted dark surface for blue player */
}

/* Player row */
.player-row {
  background: var(--surface); border-radius: 12px; padding: 12px 14px;
  border: 2px solid transparent; transition: all 0.3s ease;
}
.player-row.player-0 { background: linear-gradient(135deg, rgba(231,76,60,0.2), var(--p0-surface)); border-color: rgba(231,76,60,0.3); }
.player-row.player-1 { background: linear-gradient(135deg, rgba(52,152,219,0.2), var(--p1-surface)); border-color: rgba(52,152,219,0.3); }
.player-row.player-0.active-turn {
  border-color: var(--p0); box-shadow: 0 0 20px var(--p0-glow), 0 0 40px rgba(231,76,60,0.15);
  transform: scale(1.02); background: linear-gradient(135deg, rgba(231,76,60,0.3), var(--p0-surface));
}
.player-row.player-1.active-turn {
  border-color: var(--p1); box-shadow: 0 0 20px var(--p1-glow), 0 0 40px rgba(52,152,219,0.15);
  transform: scale(1.02); background: linear-gradient(135deg, rgba(52,152,219,0.3), var(--p1-surface));
}
.player-row:not(.active-turn) { opacity: 0.6; }
.player-row-header {
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 10px;
}
.player-row-name {
  font-size: 15px; font-weight: 700;
}
.player-row.player-0 .player-row-name { color: #f1948a; }
.player-row.player-1 .player-row-name { color: #85c1e9; }
.player-row-name .star { margin-left: 4px; }
.player-row.player-0 .player-row-name .star { color: var(--p0); }
.player-row.player-1 .player-row-name .star { color: var(--p1); }
.player-row-score {
  font-size: 13px; color: var(--text-dim);
}

/* Card row (horizontal scroll) */
.card-row {
  display: flex; align-items: center; gap: 6px;
  overflow-x: auto; padding: 4px 0 8px;
  scrollbar-width: thin; scrollbar-color: #444 transparent;
}
.card-row::-webkit-scrollbar { height: 4px; }
.card-row::-webkit-scrollbar-thumb { background: #444; border-radius: 2px; }

/* Game card â€” size driven by CSS vars set by computeCardSize() */
.game-card {
  width: var(--card-w, 90px); min-width: var(--card-w, 90px);
  height: var(--card-h, 110px);
  background: var(--card-bg); border-radius: 10px;
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; padding: 8px 6px; cursor: pointer;
  border: 2px solid transparent; transition: border-color 0.2s, box-shadow 0.2s;
  flex-shrink: 0; position: relative; user-select: none;
  perspective: 600px;
}

/* Album art on cards */
.game-card-art {
  width: 48px; height: 48px; border-radius: 6px; object-fit: cover;
  margin-bottom: 4px; flex-shrink: 0;
}
/* Large tier: bigger art */
.card-size-large .game-card-art { width: 80px; height: 80px; border-radius: 8px; margin-bottom: 6px; }
/* Small tier: hide art */
.card-size-small .game-card-art { display: none; }
/* Art placeholder fallback */
.game-card-art-placeholder { box-sizing: border-box; }
.game-card.card-p0 { border-color: rgba(231,76,60,0.3); }
.game-card.card-p1 { border-color: rgba(52,152,219,0.3); }
.game-card.card-p0:hover { border-color: rgba(231,76,60,0.6); }
.game-card.card-p1:hover { border-color: rgba(52,152,219,0.6); }
.game-card:active { transform: scale(0.97); }

/* Card pop-out overlay */
.card-popout-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.7);
  display: flex; align-items: center; justify-content: center;
  z-index: 250; padding: 20px; animation: fadeIn 0.15s ease-out;
}
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
.card-popout {
  background: var(--card-bg); border-radius: 20px; padding: 28px 24px;
  min-width: 240px; max-width: 320px; text-align: center;
  border: 3px solid transparent;
  box-shadow: 0 8px 40px rgba(0,0,0,0.5);
  animation: popIn 0.2s ease-out;
}
@keyframes popIn { from { transform: scale(0.85); opacity: 0; } to { transform: scale(1); opacity: 1; } }
.card-popout.popout-p0 { border-color: rgba(231,76,60,0.5); }
.card-popout.popout-p1 { border-color: rgba(52,152,219,0.5); }
.card-popout-art {
  width: 160px; height: 160px; border-radius: 12px; object-fit: cover;
  margin: 0 auto 14px; display: block;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
}
.card-popout-year {
  font-size: 52px; font-weight: 800; line-height: 1.1; margin-bottom: 8px;
}
.card-popout.popout-p0 .card-popout-year { color: var(--p0); }
.card-popout.popout-p1 .card-popout-year { color: var(--p1); }
.card-popout-artist { font-size: 18px; font-weight: 600; color: var(--text); margin-bottom: 4px; }
.card-popout-title { font-size: 15px; color: var(--text-dim); margin-bottom: 20px; }
.card-popout-play {
  width: 56px; height: 56px; border-radius: 50%;
  background: #fff; border: none; cursor: pointer;
  display: inline-flex; align-items: center; justify-content: center;
  transition: transform 0.15s, box-shadow 0.15s;
  box-shadow: 0 2px 12px rgba(0,0,0,0.3);
}
.card-popout-play:hover { transform: scale(1.08); box-shadow: 0 4px 20px rgba(0,0,0,0.4); }
.card-popout-play:active { transform: scale(0.95); }
.card-popout-play svg { width: 24px; height: 24px; fill: #000; }
.game-card-year {
  font-size: 26px; font-weight: 800; color: var(--accent); line-height: 1.1;
}
.game-card.card-p0 .game-card-year { color: var(--p0); }
.game-card.card-p1 .game-card-year { color: var(--p1); }
.game-card-artist {
  font-size: 11px; font-weight: 600; color: var(--text);
  text-align: center; margin-top: 4px;
  max-width: 100%; overflow: hidden; text-overflow: ellipsis;
  white-space: nowrap;
}
.game-card-title {
  font-size: 10px; color: var(--text-dim);
  text-align: center; max-width: 100%;
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
/* Card tier text sizing */
.card-size-large .game-card-year { font-size: 28px; }
.card-size-large .game-card-artist { font-size: 12px; }
.card-size-large .game-card-title { font-size: 11px; }
.card-size-medium .game-card-year { font-size: 22px; }
.card-size-medium .game-card-artist { font-size: 11px; }
.card-size-medium .game-card-title { font-size: 10px; }

/* Card flip animation */
.game-card-inner {
  width: 100%; height: 100%;
  display: flex; flex-direction: column; align-items: center;
  justify-content: center;
  transition: transform 0.5s;
  transform-style: preserve-3d;
  position: relative;
}
.game-card.flipping .game-card-inner {
  transform: rotateY(180deg);
}
.game-card-face {
  backface-visibility: hidden;
  position: absolute; width: 100%; height: 100%;
  display: flex; flex-direction: column; align-items: center;
  justify-content: center;
}
.game-card-back {
  transform: rotateY(180deg);
}
.game-card-front {
  background: var(--surface2); border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
}
.game-card-front svg { width: 28px; height: 28px; fill: var(--text-dim); }

/* Placement slot */
.placement-slot {
  min-width: 44px; height: var(--card-h, 110px);
  border: 2px dashed rgba(255,255,255,0.2); border-radius: 10px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; flex-shrink: 0;
  font-size: 22px; color: rgba(255,255,255,0.4);
  transition: background 0.2s, border-color 0.2s;
  animation: slotPulse 2s ease-in-out infinite;
}
.placement-slot.slot-p0 { border-color: rgba(231,76,60,0.4); color: rgba(231,76,60,0.6); }
.placement-slot.slot-p1 { border-color: rgba(52,152,219,0.4); color: rgba(52,152,219,0.6); }
.placement-slot.slot-p0:hover { background: rgba(231,76,60,0.1); border-color: var(--p0); color: var(--p0); }
.placement-slot.slot-p1:hover { background: rgba(52,152,219,0.1); border-color: var(--p1); color: var(--p1); }
.placement-slot.empty-row {
  min-width: 120px; font-size: 14px; font-weight: 600;
}
@keyframes slotPulse {
  0%, 100% { opacity: 0.7; }
  50% { opacity: 1; }
}

/* Card animations */
@keyframes glowP0 {
  0% { box-shadow: 0 0 0 rgba(231,76,60,0); }
  50% { box-shadow: 0 0 20px rgba(231,76,60,0.6); }
  100% { box-shadow: 0 0 0 rgba(231,76,60,0); }
}
@keyframes glowP1 {
  0% { box-shadow: 0 0 0 rgba(52,152,219,0); }
  50% { box-shadow: 0 0 20px rgba(52,152,219,0.6); }
  100% { box-shadow: 0 0 0 rgba(52,152,219,0); }
}
@keyframes greenGlow {
  0% { box-shadow: 0 0 0 rgba(29, 185, 84, 0); }
  50% { box-shadow: 0 0 20px rgba(29, 185, 84, 0.6); }
  100% { box-shadow: 0 0 0 rgba(29, 185, 84, 0); }
}
.game-card.correct-glow {
  animation: greenGlow 1s ease-out;
  border-color: var(--accent);
}
.game-card.card-p0.correct-glow { animation: glowP0 1s ease-out; border-color: var(--p0); }
.game-card.card-p1.correct-glow { animation: glowP1 1s ease-out; border-color: var(--p1); }

@keyframes redShake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
  20%, 40%, 60%, 80% { transform: translateX(4px); }
}
@keyframes slideOut {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  100% { opacity: 0; transform: translateY(60px) scale(0.7); }
}
.game-card.wrong-shake {
  animation: redShake 0.5s ease-out;
  border-color: var(--danger);
}
.game-card.wrong-slide {
  animation: slideOut 0.4s ease-in forwards;
}

.game-card.replay-pulse { animation: greenGlow 0.6s ease-out; }
.game-card.card-p0.replay-pulse { animation: glowP0 0.6s ease-out; }
.game-card.card-p1.replay-pulse { animation: glowP1 0.6s ease-out; }

/* Visual discard pile on game board */
.discard-pile-visual {
  display: flex; flex-direction: column; align-items: center; gap: 6px;
  cursor: pointer; align-self: center;
}
.discard-pile-card-empty {
  min-width: var(--card-w, 90px); height: var(--card-h, 110px); border-radius: 10px;
  border: 2px dashed rgba(255,255,255,0.15);
  display: flex; align-items: center; justify-content: center;
  color: var(--text-dim); font-size: 13px;
}
.discard-pile-card {
  min-width: var(--card-w, 90px); width: var(--card-w, 90px); height: var(--card-h, 110px);
  background: var(--card-bg); border-radius: 10px;
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; padding: 8px 6px;
  border: 2px solid transparent; position: relative;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  transition: transform 0.15s;
}
.discard-pile-card:hover { transform: scale(1.05); }
.discard-pile-card.card-p0 { border-color: rgba(231,76,60,0.4); }
.discard-pile-card.card-p1 { border-color: rgba(52,152,219,0.4); }
.discard-pile-card.card-p0 .game-card-year { color: var(--p0); }
.discard-pile-card.card-p1 .game-card-year { color: var(--p1); }
.discard-pile-count {
  position: absolute; top: -8px; right: -8px;
  background: var(--danger); color: #fff; font-size: 12px; font-weight: 700;
  width: 24px; height: 24px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
}
.discard-pile-label {
  font-size: 13px; color: var(--text-dim); font-weight: 600;
}

/* Deck + discard fixed sidebar */
.game-piles {
  position: fixed; right: 0; top: 48px; bottom: 0;
  width: var(--piles-sidebar-w, 180px);
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; gap: 28px;
  background: linear-gradient(180deg, var(--surface) 0%, rgba(26,26,46,0.95) 100%);
  border-left: 1px solid #333;
  z-index: 9; padding: 16px 12px;
  /* Override card sizes to fit sidebar */
  --card-w: 130px; --card-h: 160px;
}
.deck-visual {
  display: flex; flex-direction: column; align-items: center; gap: 6px;
  cursor: pointer;
}
.deck-card {
  min-width: var(--card-w, 90px); width: var(--card-w, 90px); height: var(--card-h, 110px);
  background: var(--surface2); border-radius: 10px;
  display: flex; align-items: center; justify-content: center;
  border: 2px solid transparent; position: relative;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4), 3px 3px 0 var(--card-bg), 6px 6px 0 var(--surface), 9px 9px 0 var(--card-bg);
  transition: transform 0.15s;
}
.deck-card:hover { transform: scale(1.05); }
.deck-card.deck-p0 { border-color: rgba(231,76,60,0.5); background: linear-gradient(135deg, rgba(231,76,60,0.15), var(--surface2)); }
.deck-card.deck-p1 { border-color: rgba(52,152,219,0.5); background: linear-gradient(135deg, rgba(52,152,219,0.15), var(--surface2)); }
.deck-card svg { width: 44px; height: 44px; opacity: 0.4; }
.deck-card.deck-p0 svg { fill: var(--p0); }
.deck-card.deck-p1 svg { fill: var(--p1); }
.deck-card.dealing { opacity: 0; transition: opacity 0.2s ease-out; pointer-events: none; }
@keyframes deckPulse {
  0%, 100% { box-shadow: 0 4px 12px rgba(0,0,0,0.4), 3px 3px 0 var(--card-bg), 6px 6px 0 var(--surface), 9px 9px 0 var(--card-bg), 0 0 0 0 rgba(29,185,84,0); }
  50% { box-shadow: 0 4px 12px rgba(0,0,0,0.4), 3px 3px 0 var(--card-bg), 6px 6px 0 var(--surface), 9px 9px 0 var(--card-bg), 0 0 20px 6px rgba(29,185,84,0.35); }
}
.deck-card.deck-next-turn { animation: deckPulse 1.5s ease-in-out infinite; cursor: pointer; }
.deck-label { font-size: 13px; color: var(--text-dim); font-weight: 600; }
.deck-count {
  position: absolute; top: -8px; right: -8px;
  background: var(--accent); color: #000; font-size: 12px; font-weight: 700;
  width: 24px; height: 24px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
}

/* Responsive: shrink piles sidebar on narrow screens */
@media (max-width: 768px) {
  .game-piles {
    --piles-sidebar-w: 120px;
    width: var(--piles-sidebar-w);
    --card-w: 90px; --card-h: 110px;
    gap: 20px; padding: 10px 6px;
  }
  .game-piles .deck-card svg { width: 32px; height: 32px; }
  .game-body { padding-right: calc(var(--piles-sidebar-w, 120px) + 12px); }
}

/* Discard modal */
.discard-modal-list {
  display: flex; flex-direction: column; gap: 8px;
  max-height: 60vh; overflow-y: auto;
}
.discard-item {
  display: flex; align-items: center; gap: 10px;
  background: var(--bg); border-radius: 8px; padding: 10px;
  cursor: pointer; transition: background 0.2s;
  border-left: 3px solid transparent;
}
.discard-item.discard-p0 { border-left-color: var(--p0); background: linear-gradient(90deg, rgba(231,76,60,0.08), var(--bg) 40%); }
.discard-item.discard-p1 { border-left-color: var(--p1); background: linear-gradient(90deg, rgba(52,152,219,0.08), var(--bg) 40%); }
.discard-item:hover { background: var(--surface2); }
.discard-item-year {
  font-size: 20px; font-weight: 800; color: var(--accent); min-width: 50px; text-align: center;
}
.discard-item.discard-p0 .discard-item-year { color: var(--p0); }
.discard-item.discard-p1 .discard-item-year { color: var(--p1); }
.discard-item-info { flex: 1; min-width: 0; }
.discard-item-artist {
  font-size: 13px; font-weight: 600;
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.discard-item-title {
  font-size: 12px; color: var(--text-dim);
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.discard-item-player {
  font-size: 11px; color: var(--text-dim);
}

/* Victory overlay */
.victory-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.85);
  display: flex; align-items: center; justify-content: center;
  z-index: 250; padding: 20px;
}
.victory-overlay.hidden { display: none; }
.victory-card {
  background: var(--surface); border-radius: 20px; padding: 40px 30px;
  text-align: center; max-width: 400px; width: 100%;
  border: 2px solid var(--accent);
  box-shadow: 0 0 40px rgba(29, 185, 84, 0.3);
}
.victory-card.victory-p0 { border-color: var(--p0); box-shadow: 0 0 40px var(--p0-glow); }
.victory-card.victory-p1 { border-color: var(--p1); box-shadow: 0 0 40px var(--p1-glow); }
.victory-title {
  font-size: 28px; font-weight: 800; color: var(--accent);
  margin-bottom: 8px;
}
.victory-card.victory-p0 .victory-title { color: var(--p0); }
.victory-card.victory-p1 .victory-title { color: var(--p1); }
.victory-subtitle {
  font-size: 16px; color: var(--text-dim); margin-bottom: 24px;
}
.victory-actions { display: flex; flex-direction: column; gap: 10px; }

/* Setup modal additions */
.setup-player-inputs { display: flex; flex-direction: column; gap: 10px; margin-bottom: 16px; }
.setup-player-inputs input {
  background: var(--bg); border: 1px solid #444; border-radius: 8px;
  color: var(--text); padding: 10px; font-size: 14px; width: 100%;
}
.setup-player-inputs label {
  font-size: 13px; color: var(--text-dim); margin-bottom: 2px;
}
.setup-win-row { display: flex; align-items: center; gap: 10px; margin-bottom: 16px; }
.setup-win-row label { font-size: 13px; color: var(--text-dim); }
.setup-win-row select {
  background: var(--bg); border: 1px solid #444; border-radius: 8px;
  color: var(--text); padding: 6px 10px; font-size: 14px;
}

/* Wide screens: give sidebar more room */
@media (min-width: 900px) {
  :root { --piles-sidebar-w: 140px; }
}

/* Guess result flash overlay */
.guess-flash {
  position: fixed; inset: 0; z-index: 200; pointer-events: none;
  animation: flashFade 0.7s ease-out forwards;
}
.guess-flash.correct { background: rgba(29, 185, 84, 0.25); }
.guess-flash.wrong { background: rgba(231, 76, 60, 0.3); }
@keyframes flashFade {
  0% { opacity: 1; }
  100% { opacity: 0; }
}

/* Guess result banner */
.guess-banner {
  position: fixed; top: 56px; left: 50%; transform: translateX(-50%);
  z-index: 210; padding: 10px 28px; border-radius: 12px;
  font-size: 17px; font-weight: 700; text-align: center;
  animation: bannerSlide 1.4s ease-out forwards;
  pointer-events: none; white-space: nowrap;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
}
.guess-banner.correct {
  background: var(--accent); color: #000;
}
.guess-banner.wrong {
  background: var(--danger); color: #fff;
}
@keyframes bannerSlide {
  0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
  15% { opacity: 1; transform: translateX(-50%) translateY(0); }
  75% { opacity: 1; }
  100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
}

/* ==================== TOKEN MODE ==================== */

/* Setup modal mode toggle */
.setup-mode-toggle {
  display: flex; border-radius: 10px; overflow: hidden;
  border: 1px solid #444; margin-bottom: 8px;
}
.setup-mode-btn {
  flex: 1; padding: 10px; font-size: 14px; font-weight: 600;
  background: var(--bg); color: var(--text-dim); border: none;
  cursor: pointer; transition: background 0.2s, color 0.2s;
  text-align: center;
}
.setup-mode-btn.active {
  background: var(--accent); color: #000;
}
.setup-mode-hint {
  font-size: 12px; color: var(--text-dim); margin-bottom: 14px;
  line-height: 1.4;
}

/* Token counter in player header */
.player-token-count {
  display: inline-flex; align-items: center; gap: 3px;
  font-size: 13px; font-weight: 700; color: #f1c40f;
  margin-left: 8px;
}

/* Token controls (active player) */
.token-controls {
  margin-bottom: 8px;
}
.token-guess-input {
  background: var(--bg); border: 1px solid #444; border-radius: 8px;
  color: var(--text); padding: 8px 12px; width: 100%; font-size: 14px;
  font-family: inherit; margin-bottom: 6px;
}
.token-guess-input::placeholder { color: var(--text-dim); }
.token-actions-row {
  display: flex; gap: 8px;
}
.token-actions-row .btn {
  flex: 1; padding: 8px 12px; font-size: 13px; border-radius: 10px;
}
.token-actions-row .btn:disabled {
  opacity: 0.35; cursor: not-allowed;
}
.token-buy-btn {
  background: #f1c40f; color: #000;
}
.token-buy-btn:hover:not(:disabled) { background: #f4d03f; }
.token-skip-btn {
  background: var(--surface2); color: var(--text);
  border: 1px solid #555;
}
.token-skip-btn:hover:not(:disabled) { background: #1a3a5c; }

/* Challenge buzzer */
.challenge-buzzer {
  padding: 6px 14px; border-radius: 10px; font-size: 13px; font-weight: 700;
  border: 2px solid; cursor: pointer;
  transition: all 0.2s; background: transparent;
}
.challenge-buzzer.buzzer-p0 {
  border-color: var(--p0); color: var(--p0);
}
.challenge-buzzer.buzzer-p1 {
  border-color: var(--p1); color: var(--p1);
}
.challenge-buzzer.buzzer-active.buzzer-p0 {
  background: var(--p0); color: #fff;
  animation: buzzerPulse0 1s ease-in-out infinite;
}
.challenge-buzzer.buzzer-active.buzzer-p1 {
  background: var(--p1); color: #fff;
  animation: buzzerPulse1 1s ease-in-out infinite;
}
@keyframes buzzerPulse0 {
  0%, 100% { box-shadow: 0 0 0 0 rgba(231,76,60,0.4); }
  50% { box-shadow: 0 0 12px 4px rgba(231,76,60,0.5); }
}
@keyframes buzzerPulse1 {
  0%, 100% { box-shadow: 0 0 0 0 rgba(52,152,219,0.4); }
  50% { box-shadow: 0 0 12px 4px rgba(52,152,219,0.5); }
}

/* Rules modal */
.rules-modal-body {
  max-height: 65vh; overflow-y: auto;
}
.rules-section { margin-bottom: 18px; }
.rules-section h3 {
  font-size: 15px; margin-bottom: 8px; color: var(--accent);
}
.rules-section ol, .rules-section ul {
  padding-left: 20px; font-size: 13px; color: var(--text-dim); line-height: 1.7;
}
.rules-section li { margin-bottom: 4px; }
.rules-action-card {
  background: var(--bg); border-radius: 10px; padding: 10px 14px;
  margin-bottom: 8px; border-left: 3px solid #f1c40f;
}
.rules-action-card strong { color: #f1c40f; }
.rules-action-card .rules-cost { font-size: 12px; color: var(--text-dim); }

/* Home rules button */
.home-rules-btn {
  background: none; border: none; color: var(--text-dim);
  font-size: 14px; cursor: pointer; padding: 8px;
  text-decoration: underline; margin-top: 4px;
}
.home-rules-btn:hover { color: var(--text); }

/* Title judgement badge (top-right, non-blocking) */
.title-judge {
  position: fixed; top: 56px; right: 12px;
  z-index: 210; border-radius: 12px; padding: 8px 14px;
  background: var(--surface); border: 2px solid #444;
  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
  text-align: center; max-width: 200px;
  animation: judgeSlideIn 0.2s ease-out;
}
@keyframes judgeSlideIn {
  from { opacity: 0; transform: translateX(12px); }
  to { opacity: 1; transform: translateX(0); }
}
.title-judge.matched { border-color: var(--accent); }
.title-judge.no-match { border-color: var(--danger); }
.title-judge-verdict {
  font-size: 13px; font-weight: 700; margin-bottom: 6px;
}
.title-judge.matched .title-judge-verdict { color: var(--accent); }
.title-judge.no-match .title-judge-verdict { color: var(--danger); }
.title-judge-override {
  padding: 5px 14px; border-radius: 8px; font-size: 12px;
  font-weight: 600; cursor: pointer; border: 1px solid #555;
  background: var(--surface2); color: var(--text);
  transition: transform 0.1s;
}
.title-judge-override:active { transform: scale(0.95); }

/* Device picker */
.device-item {
  display: block; width: 100%; text-align: left;
  background: var(--bg); border: 1px solid #444; border-radius: 10px;
  color: var(--text); padding: 14px 16px; font-size: 15px;
  cursor: pointer; margin-bottom: 8px; transition: border-color 0.2s;
}
.device-item:hover { border-color: var(--accent); }
.device-item.selected { border-color: var(--accent); color: var(--accent); font-weight: 600; }
.device-picker-hint {
  font-size: 12px; color: var(--text-dim); margin-bottom: 14px;
}

/* Game topbar device button */
.game-topbar-device {
  background: none; border: none; color: var(--text-dim);
  cursor: pointer; padding: 4px; display: flex; align-items: center;
  font-size: 18px; line-height: 1;
}
.game-topbar-device:hover { color: var(--accent); }
.game-topbar-device-name {
  font-size: 11px; color: var(--accent); max-width: 80px;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
</style>
</head>
<body>

<!-- Toast container -->
<div id="toast" class="toast toast-hidden"></div>

<!-- HOME SCREEN -->
<div id="home" class="screen active">
  <div class="logo">Hit<span>Star</span></div>
  <div class="subtitle">Spotify Edition &mdash; Plays right in your browser</div>

  <!-- Connect prompt shown when no token -->
  <div class="connect-prompt" id="home-connect-prompt">
    <p>Connect your Spotify Premium account to play music directly in the browser.</p>
    <button class="btn" onclick="connectSpotifySDK()">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
      Connect Spotify Premium
    </button>
  </div>

  <div class="home-actions" id="home-actions">
    <button class="btn" onclick="showGameSetup()">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 00-3-3.87M16 3.13a4 4 0 010 7.75"/></svg>
      Start Game
    </button>
  </div>
  <button class="home-rules-btn" onclick="showRulesModal()">How to Play</button>
  <div class="spotify-badge" id="home-spotify-badge">
    <svg viewBox="0 0 24 24"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
    <span id="home-badge-text">Connect Spotify to play</span>
  </div>
</div>

<!-- NOW PLAYING SCREEN -->
<div id="now-playing" class="screen">
  <!-- Pre-reveal: just shows that music is playing, no song info -->
  <div id="np-listening" class="np-card" style="text-align:center">
    <div class="np-category" id="np-category"></div>
    <div class="np-listening-icon">
      <svg width="64" height="64" viewBox="0 0 24 24" fill="var(--accent)" opacity="0.8"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
    </div>
    <div id="np-status-text" style="font-size:18px;font-weight:600;margin:16px 0 6px">Now playing</div>
    <div id="np-status-sub" style="font-size:14px;color:var(--text-dim)">Listen and guess the song!</div>
    <!-- SDK player controls (pre-reveal) -->
    <div class="sdk-player-controls" id="np-controls-listening">
      <button class="sdk-play-btn" id="sdk-play-btn-listening" onclick="togglePlayback()">
        <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
      </button>
      <div class="sdk-progress-wrap" id="sdk-progress-wrap-listening" onclick="seekPlayback(event, this)">
        <div class="sdk-progress-bar" id="sdk-progress-bar-listening"></div>
      </div>
    </div>
    <div class="sdk-player-error" id="sdk-error-listening"></div>
  </div>

  <!-- Post-reveal: shows full song info -->
  <div id="np-revealed" class="np-card" style="display:none">
    <div class="np-category" id="np-category-rev"></div>
    <div class="np-artist" id="np-artist"></div>
    <div class="np-title" id="np-title"></div>
    <div class="np-year" id="np-year"></div>
    <!-- SDK player controls (post-reveal) -->
    <div class="sdk-player-controls" id="np-controls-revealed">
      <button class="sdk-play-btn" id="sdk-play-btn-revealed" onclick="togglePlayback()">
        <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
      </button>
      <div class="sdk-progress-wrap" id="sdk-progress-wrap-revealed" onclick="seekPlayback(event, this)">
        <div class="sdk-progress-bar" id="sdk-progress-bar-revealed"></div>
      </div>
    </div>
    <div class="sdk-player-error" id="sdk-error-revealed"></div>
  </div>

  <div class="np-actions">
    <button class="btn btn-block" id="btn-reveal" onclick="revealSong()" style="font-size:20px;padding:18px">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
      Reveal Answer
    </button>
    <button class="btn btn-outline btn-block btn-sm" id="btn-reopen-spotify" onclick="openCurrentInSpotify()" style="display:none">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
      Open in Spotify
    </button>
    <button class="btn btn-outline btn-block" onclick="playRandom()">Next Song</button>
    <button class="btn btn-outline btn-block btn-sm" onclick="showScreen('home')" style="border-color:#555;color:#999">Back to Home</button>
  </div>
</div>

<!-- PLAYLISTS SCREEN -->
<div id="playlists" class="screen">
  <h1>Playlists</h1>
  <div id="playlist-browser"></div>
</div>

<!-- SETTINGS SCREEN -->
<div id="settings" class="screen">
  <h1>Settings</h1>

  <div class="setting-group">
    <h3>Spotify Connection</h3>
    <p style="font-size:13px;color:var(--text-dim);margin-bottom:10px">
      Connect to Spotify Premium to play music directly in the browser via the Web Playback SDK.
    </p>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <button class="btn btn-sm" onclick="connectSpotifySDK()" id="btn-connect-sdk">Connect Spotify</button>
      <span id="sdk-connection-status" style="font-size:13px;color:var(--text-dim)"></span>
    </div>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:10px">
      <button class="btn btn-sm btn-outline" onclick="showDevicePicker()">Choose Device</button>
      <span id="current-device-name" style="font-size:13px;color:var(--accent)">HitStar Player (this browser)</span>
    </div>
  </div>

  <div class="setting-group">
    <h3>About</h3>
    <p style="font-size:13px;color:var(--text-dim)">
      HitStar Spotify Edition<br>
      A zero-download companion for the HitStar music quiz game.<br>
      Songs play right here via Spotify Web Playback SDK &mdash; Premium account required.<br><br>
      Built as part of the <a href="https://github.com/Born2Root/HitStar" target="_blank" style="color:var(--accent)">HitStar</a> open source project.
    </p>
  </div>
</div>

<!-- GAME SETUP MODAL -->
<div class="modal-overlay hidden" id="game-setup-modal">
  <div class="modal">
    <h2>New Game</h2>
    <div class="setup-player-inputs">
      <div>
        <label style="color:#f1948a">&#9679; Player 1 (Red)</label>
        <input type="text" id="setup-p1-name" placeholder="Player 1" style="border-color:rgba(231,76,60,0.4)">
      </div>
      <div>
        <label style="color:#85c1e9">&#9679; Player 2 (Blue)</label>
        <input type="text" id="setup-p2-name" placeholder="Player 2" style="border-color:rgba(52,152,219,0.4)">
      </div>
    </div>
    <div class="setup-win-row">
      <label>Cards to win:</label>
      <select id="setup-win-count">
        <option value="5">5</option>
        <option value="7">7</option>
        <option value="10" selected>10</option>
        <option value="15">15</option>
      </select>
    </div>
    <div style="margin-bottom:14px">
      <label style="font-size:13px;color:var(--text-dim);display:block;margin-bottom:6px">Game Mode</label>
      <div class="setup-mode-toggle">
        <button class="setup-mode-btn active" id="setup-mode-classic" onclick="setSetupMode('classic')">Classic</button>
        <button class="setup-mode-btn" id="setup-mode-token" onclick="setSetupMode('token')">Token Mode</button>
      </div>
      <div class="setup-mode-hint" id="setup-mode-hint">Place songs in chronological order. Wrong guesses go to the discard pile.</div>
    </div>
    <div class="modal-actions">
      <button class="btn btn-outline" onclick="closeGameSetup()">Cancel</button>
      <button class="btn" onclick="startGame()">Start Game</button>
    </div>
  </div>
</div>

<!-- GAME BOARD SCREEN -->
<div id="game-board" class="screen">
  <!-- Top bar -->
  <div class="game-topbar">
    <button class="game-topbar-device" onclick="showDevicePicker()" title="Choose output device">&#128266;</button>
    <span class="game-topbar-device-name" id="game-device-name"></span>
    <button class="sdk-play-btn" id="game-play-btn" onclick="togglePlayback()">
      <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
    </button>
    <div class="sdk-progress-wrap" onclick="seekPlayback(event, this)">
      <div class="sdk-progress-bar" id="game-progress-bar"></div>
    </div>
    <div class="game-topbar-nowplaying obfuscated" id="game-nowplaying">
      <div class="game-topbar-nowplaying-year" id="game-nowplaying-year"></div>
      <div class="game-topbar-nowplaying-text">
        <div class="game-topbar-nowplaying-artist" id="game-nowplaying-artist"></div>
        <div class="game-topbar-nowplaying-title" id="game-nowplaying-title"></div>
      </div>
    </div>
    <span class="game-topbar-status" id="game-status-text"></span>
    <button class="game-topbar-btn" onclick="showInGameRules()">Rules</button>
    <button class="game-topbar-btn" onclick="quitGame()">Quit</button>
  </div>
  <!-- Player rows -->
  <div class="game-body" id="game-body"></div>
  <!-- Reconnect button at bottom -->
  <div style="padding:8px 16px;text-align:center">
    <button class="game-topbar-btn" id="game-reconnect-btn" onclick="connectSpotifySDK()" style="display:none">Reconnect Spotify</button>
  </div>
</div>

<!-- DISCARD PILE MODAL -->
<div class="modal-overlay hidden" id="discard-modal">
  <div class="modal" style="max-width:480px">
    <h2>Discard Pile</h2>
    <div class="discard-modal-list" id="discard-list"></div>
    <div class="modal-actions" style="margin-top:14px">
      <button class="btn btn-outline btn-block" onclick="closeDiscardModal()">Close</button>
    </div>
  </div>
</div>

<!-- VICTORY OVERLAY -->
<div class="victory-overlay hidden" id="victory-overlay">
  <div class="victory-card">
    <div class="victory-title" id="victory-title">Player Wins!</div>
    <div class="victory-subtitle" id="victory-subtitle">With 10 cards</div>
    <div class="victory-actions">
      <button class="btn" onclick="showGameSetup()">Play Again</button>
      <button class="btn btn-outline" onclick="keepPlaying()">Keep Playing</button>
      <button class="btn btn-outline" onclick="quitGame()">Back to Home</button>
    </div>
  </div>
</div>

<!-- RULES MODAL -->
<div class="modal-overlay hidden" id="rules-modal">
  <div class="modal" style="max-width:480px">
    <h2>How to Play</h2>
    <div class="rules-modal-body" id="rules-modal-body"></div>
    <div class="modal-actions" style="margin-top:14px">
      <button class="btn btn-outline btn-block" onclick="closeRulesModal()">Close</button>
    </div>
  </div>
</div>

<!-- DEVICE PICKER MODAL -->
<div class="modal-overlay hidden" id="device-picker-modal">
  <div class="modal" style="max-width:400px">
    <h2>Output Device</h2>
    <p class="device-picker-hint">Choose where to play music. HitStar controls playback on any device.</p>
    <div id="device-picker-list"></div>
    <div class="modal-actions" style="margin-top:14px">
      <button class="btn btn-outline btn-block" onclick="closeDevicePicker()">Cancel</button>
    </div>
  </div>
</div>

<!-- NAVIGATION -->
<nav class="nav">
  <button onclick="showScreen('home')" id="nav-home" class="active">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-4 0a1 1 0 01-1-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 01-1 1"/></svg>
    Home
  </button>
  <button onclick="showScreen('playlists')" id="nav-playlists">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18V5l12-2v13M9 18c0 1.657-1.343 3-3 3s-3-1.343-3-3 1.343-3 3-3 3 1.343 3 3zM21 16c0 1.657-1.343 3-3 3s-3-1.343-3-3 1.343-3 3-3 3 1.343 3 3z"/></svg>
    Playlists
  </button>
  <button onclick="showScreen('settings')" id="nav-settings">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 01-2.83 2.83l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-4 0v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83-2.83l.06-.06A1.65 1.65 0 004.68 15a1.65 1.65 0 00-1.51-1H3a2 2 0 010-4h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06A1.65 1.65 0 009 4.68a1.65 1.65 0 001-1.51V3a2 2 0 014 0v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06A1.65 1.65 0 0019.4 9a1.65 1.65 0 001.51 1H21a2 2 0 010 4h-.09a1.65 1.65 0 00-1.51 1z"/></svg>
    Settings
  </button>
</nav>

<!-- Spotify Web Playback SDK -->
<script src="https://sdk.scdn.co/spotify-player.js"></script>

<script>
// ==================== STATE ====================
var currentSong = null;
var SPOTIFY_CLIENT_ID = '487c104a2e1745778856e769dec3c079';
var gameSettings = { autoReveal: 'no', activeCategories: [], spotifyClientId: SPOTIFY_CLIENT_ID };
var spotifyToken = null;
var pendingAction = null;

// SDK playback state
var sdkPlayer = null;
var sdkDeviceId = null;
var sdkReady = false;
var sdkToken = null;
var sdkTokenExpiry = 0;
var sdkRefreshToken = null;
var tokenRefreshTimer = null;
var tokenRefreshInProgress = false;
var sdkIsPlaying = false;
var sdkProgressInterval = null;
var sdkCurrentPosition = 0;
var sdkDuration = 0;
var sdkDeviceLost = false; // true when playback transferred to another device

// External device playback (null = use SDK player in browser)
var externalDeviceId = null;
var externalDeviceName = '';
var externalPollInterval = null;

// Session playlist state
var sessionPlaylist = null;

var STORAGE_KEY = 'hitstar_songs';
var SETTINGS_KEY = 'hitstar_settings';
var PENDING_KEY = 'hitstar_pending_action';
var SDK_TOKEN_KEY = 'hitstar_sdk_token';
var SDK_TOKEN_EXPIRY_KEY = 'hitstar_sdk_token_expiry';
var SDK_REFRESH_TOKEN_KEY = 'hitstar_sdk_refresh_token';
var GAME_SAVE_KEY = 'hitstar_game_save';

// SVG icon markup for play/pause buttons
var PLAY_SVG = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
var PAUSE_SVG = '<svg viewBox="0 0 24 24"><path d="M6 4h4v16H6zM14 4h4v16h-4z"/></svg>';

// Token mode constants
var TOKEN_MAX = 5;
var TOKEN_COST_BUY = 3;
var TOKEN_COST_SKIP = 1;
var TOKEN_COST_CHALLENGE = 1;

// ==================== TOAST NOTIFICATIONS ====================
var toastTimeout = null;
function showToast(msg, type, duration) {
  type = type || 'error';
  duration = duration || 4000;
  var el = document.getElementById('toast');
  el.textContent = msg;
  el.className = 'toast toast-' + type;
  clearTimeout(toastTimeout);
  toastTimeout = setTimeout(function() {
    el.classList.add('toast-hidden');
  }, duration);
}

// ==================== TOKEN MANAGEMENT ====================
function isTokenValid() {
  return sdkToken && Date.now() < sdkTokenExpiry - 60000; // 1 min buffer
}

function scheduleTokenRefresh() {
  if (tokenRefreshTimer) clearTimeout(tokenRefreshTimer);
  if (!sdkRefreshToken || !sdkTokenExpiry) return;
  // Refresh 5 minutes before expiry (or immediately if already within window)
  var refreshAt = sdkTokenExpiry - 5 * 60 * 1000;
  var delay = Math.max(0, refreshAt - Date.now());
  tokenRefreshTimer = setTimeout(function() {
    refreshAccessToken();
  }, delay);
}

async function refreshAccessToken() {
  if (!sdkRefreshToken || tokenRefreshInProgress) return false;
  tokenRefreshInProgress = true;
  try {
    var resp = await fetch('https://accounts.spotify.com/api/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: 'grant_type=refresh_token&refresh_token=' + encodeURIComponent(sdkRefreshToken)
        + '&client_id=' + encodeURIComponent(SPOTIFY_CLIENT_ID)
    });
    if (!resp.ok) {
      tokenRefreshInProgress = false;
      return false;
    }
    var data = await resp.json();
    if (!data.access_token) {
      tokenRefreshInProgress = false;
      return false;
    }
    sdkToken = data.access_token;
    sdkTokenExpiry = Date.now() + (data.expires_in || 3600) * 1000;
    if (data.refresh_token) {
      sdkRefreshToken = data.refresh_token;
      localStorage.setItem(SDK_REFRESH_TOKEN_KEY, sdkRefreshToken);
    }
    localStorage.setItem(SDK_TOKEN_KEY, sdkToken);
    localStorage.setItem(SDK_TOKEN_EXPIRY_KEY, String(sdkTokenExpiry));
    // Also update the spotifyToken alias if it was set (for import/lookup flows)
    if (spotifyToken) spotifyToken = sdkToken;
    scheduleTokenRefresh();
    tokenRefreshInProgress = false;
    return true;
  } catch (e) {
    tokenRefreshInProgress = false;
    return false;
  }
}

async function spotifyFetch(url, options) {
  options = options || {};
  if (!options.headers) options.headers = {};
  options.headers['Authorization'] = 'Bearer ' + sdkToken;

  // Proactively refresh if token is near expiry
  if (!isTokenValid() && sdkRefreshToken) {
    var refreshed = await refreshAccessToken();
    if (refreshed) {
      options.headers['Authorization'] = 'Bearer ' + sdkToken;
    }
  }

  var resp = await fetch(url, options);

  // Handle 401: try refresh once, then retry
  if (resp.status === 401 && sdkRefreshToken) {
    var refreshed = await refreshAccessToken();
    if (refreshed) {
      options.headers['Authorization'] = 'Bearer ' + sdkToken;
      resp = await fetch(url, options);
    }
  }

  // Handle 429: respect Retry-After and retry once
  if (resp.status === 429) {
    var retryAfter = parseInt(resp.headers.get('Retry-After') || '2');
    await new Promise(function(r) { setTimeout(r, retryAfter * 1000); });
    resp = await fetch(url, options);
  }

  return resp;
}

// ==================== SPOTIFY WEB PLAYBACK SDK ====================
window.onSpotifyWebPlaybackSDKReady = function() {
  if (sdkToken && Date.now() < sdkTokenExpiry) {
    initializeSDKPlayer();
  }
};

function initializeSDKPlayer() {
  if (sdkPlayer) {
    sdkPlayer.disconnect();
  }

  sdkPlayer = new Spotify.Player({
    name: 'HitStar Player',
    getOAuthToken: function(cb) { cb(sdkToken); },
    volume: 0.8
  });

  sdkPlayer.addListener('initialization_error', function(e) {
    showToast('Player init failed: ' + e.message, 'error');
    updateSDKStatus('Init error');
  });
  sdkPlayer.addListener('authentication_error', function(e) {
    showToast('Spotify auth failed. Please reconnect.', 'error');
    sdkReady = false;
    sdkDeviceId = null;
    updateSDKStatus('Auth error');
    updateHomeConnectUI();
  });
  sdkPlayer.addListener('account_error', function(e) {
    showToast('Spotify account error: ' + (e.message || 'check your subscription'), 'error');
    updateSDKStatus('Account error');
  });
  sdkPlayer.addListener('playback_error', function(e) {
    // Ignore SDK errors when playing on an external device â€” the SDK player
    // has no track loaded, which is expected
    if (externalDeviceId) return;
    showToast('Playback error: ' + e.message, 'error');
    showPlayerError('Playback error - try another track');
  });

  sdkPlayer.addListener('ready', function(data) {
    sdkDeviceId = data.device_id;
    sdkReady = true;
    updateSDKStatus('Connected');
    updateHomeConnectUI();
    showGameReconnectBtn(false);
    showToast('Spotify connected - ready to play!', 'success', 3000);
  });

  sdkPlayer.addListener('not_ready', function(data) {
    sdkReady = false;
    sdkDeviceId = null;
    updateSDKStatus('Device offline');
    updateHomeConnectUI();
  });

  sdkPlayer.addListener('player_state_changed', function(state) {
    if (!state) {
      // When intentionally on external device, ignore SDK state changes â€”
      // the external polling handles everything
      if (externalDeviceId) return;
      // Playback was transferred to another device unexpectedly
      sdkIsPlaying = false;
      sdkDeviceLost = true;
      updatePlayPauseButtons();
      stopProgressTracking();
      return;
    }
    // If using external device, don't let SDK state override polling data
    if (externalDeviceId) return;
    sdkDeviceLost = false;
    sdkIsPlaying = !state.paused;
    sdkCurrentPosition = state.position;
    sdkDuration = state.duration;
    updatePlayPauseButtons();
    updateProgressBars();
    if (sdkIsPlaying) {
      startProgressTracking();
    } else {
      stopProgressTracking();
    }
  });

  sdkPlayer.connect();
}

function updateSDKStatus(text) {
  var statusEl = document.getElementById('sdk-connection-status');
  if (statusEl) {
    statusEl.textContent = text;
    statusEl.style.color = (text === 'Connected') ? 'var(--accent)' : 'var(--text-dim)';
  }
  var btnEl = document.getElementById('btn-connect-sdk');
  if (btnEl) {
    btnEl.textContent = sdkReady ? 'Reconnect' : 'Connect Spotify';
  }
  var badgeEl = document.getElementById('home-badge-text');
  if (badgeEl) {
    badgeEl.textContent = sdkReady ? 'Connected - plays in browser' : 'Connect Spotify to play';
  }
}

function updateHomeConnectUI() {
  var prompt = document.getElementById('home-connect-prompt');
  if (!prompt) return;
  prompt.style.display = sdkReady ? 'none' : '';
}

function showGameReconnectBtn(show) {
  var btn = document.getElementById('game-reconnect-btn');
  if (btn) btn.style.display = show ? '' : 'none';
}

function connectSpotifySDK() {
  gameSettings.spotifyClientId = SPOTIFY_CLIENT_ID;
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(gameSettings));
  requireSpotifyAuth('sdk');
}

// Transfer playback back to HitStar Player when another device took over
async function transferToHitStar() {
  if (!sdkDeviceId || !isTokenValid()) return false;
  try {
    var resp = await spotifyFetch('https://api.spotify.com/v1/me/player', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ device_ids: [sdkDeviceId], play: false })
    });
    if (resp.status === 204 || resp.status === 200) {
      sdkDeviceLost = false;
      return true;
    }
    return false;
  } catch (e) {
    return false;
  }
}

// Pause playback on whichever device is active
function pausePlayback() {
  if (externalDeviceId) {
    sdkIsPlaying = false;
    updatePlayPauseButtons();
    fetch('https://api.spotify.com/v1/me/player/pause', {
      method: 'PUT',
      headers: { 'Authorization': 'Bearer ' + sdkToken }
    }).then(function(resp) {
      if (!resp.ok) {
        sdkIsPlaying = true;
        updatePlayPauseButtons();
        showToast('Failed to pause playback', 'error');
      }
    }).catch(function() {
      sdkIsPlaying = true;
      updatePlayPauseButtons();
      showToast('Failed to pause playback', 'error');
    });
  } else if (sdkPlayer) {
    sdkPlayer.pause();
  }
}

// ==================== PLAY/PAUSE CONTROLS ====================
function updatePlayPauseButtons() {
  var btn1 = document.getElementById('sdk-play-btn-listening');
  var btn2 = document.getElementById('sdk-play-btn-revealed');
  if (sdkIsPlaying) {
    if (btn1) btn1.innerHTML = PAUSE_SVG;
    if (btn2) btn2.innerHTML = PAUSE_SVG;
  } else {
    if (btn1) btn1.innerHTML = PLAY_SVG;
    if (btn2) btn2.innerHTML = PLAY_SVG;
  }
}

async function togglePlayback() {
  if (externalDeviceId) {
    if (!isTokenValid()) return;
    var endpoint = sdkIsPlaying ? 'pause' : 'play';
    sdkIsPlaying = !sdkIsPlaying;
    updatePlayPauseButtons();
    try {
      var resp = await spotifyFetch('https://api.spotify.com/v1/me/player/' + endpoint, {
        method: 'PUT'
      });
      if (!resp || !resp.ok) {
        sdkIsPlaying = !sdkIsPlaying;
        updatePlayPauseButtons();
        showToast('Playback toggle failed', 'error');
      }
    } catch (e) {
      sdkIsPlaying = !sdkIsPlaying;
      updatePlayPauseButtons();
      showToast('Playback toggle failed', 'error');
    }
    return;
  }
  if (!sdkPlayer || !sdkReady) {
    showToast('Spotify not connected. Go to Settings to connect.', 'error');
    return;
  }
  if (sdkDeviceLost) {
    await transferToHitStar();
  }
  sdkPlayer.togglePlay();
}

async function seekPlayback(event, wrapEl) {
  if (sdkDuration === 0) return;
  var rect = wrapEl.getBoundingClientRect();
  var x = event.clientX - rect.left;
  var pct = Math.max(0, Math.min(1, x / rect.width));
  var posMs = Math.floor(pct * sdkDuration);
  if (externalDeviceId) {
    if (!isTokenValid()) return;
    var prevPosition = sdkCurrentPosition;
    sdkCurrentPosition = posMs;
    updateProgressBars();
    try {
      var resp = await spotifyFetch('https://api.spotify.com/v1/me/player/seek?position_ms=' + posMs, {
        method: 'PUT'
      });
      if (!resp || !resp.ok) {
        sdkCurrentPosition = prevPosition;
        updateProgressBars();
        showToast('Seek failed', 'error');
      }
    } catch (e) {
      sdkCurrentPosition = prevPosition;
      updateProgressBars();
      showToast('Seek failed', 'error');
    }
    return;
  }
  if (!sdkPlayer || !sdkReady) return;
  sdkPlayer.seek(posMs);
}

// ==================== PROGRESS TRACKING ====================
function startProgressTracking() {
  stopProgressTracking();
  sdkProgressInterval = setInterval(function() {
    if (sdkIsPlaying && sdkDuration > 0) {
      sdkCurrentPosition += 300;
      if (sdkCurrentPosition > sdkDuration) sdkCurrentPosition = sdkDuration;
      updateProgressBars();
    }
  }, 300);
}

function stopProgressTracking() {
  if (sdkProgressInterval) {
    clearInterval(sdkProgressInterval);
    sdkProgressInterval = null;
  }
}

function updateProgressBars() {
  var pct = sdkDuration > 0 ? (sdkCurrentPosition / sdkDuration * 100) : 0;
  var bar1 = document.getElementById('sdk-progress-bar-listening');
  var bar2 = document.getElementById('sdk-progress-bar-revealed');
  if (bar1) bar1.style.width = pct + '%';
  if (bar2) bar2.style.width = pct + '%';
}

function resetProgressBars() {
  sdkCurrentPosition = 0;
  sdkDuration = 0;
  sdkIsPlaying = false;
  updateProgressBars();
  updatePlayPauseButtons();
  stopProgressTracking();
}

// ==================== EXTERNAL DEVICE POLLING ====================
function pollExternalState() {
  if (!externalDeviceId || !isTokenValid()) return;
  fetch('https://api.spotify.com/v1/me/player', {
    headers: { 'Authorization': 'Bearer ' + sdkToken }
  }).then(function(resp) {
    if (resp.status === 204) return null; // no active playback
    if (resp.status === 401) {
      // Token expired â€” attempt refresh
      refreshAccessToken();
      return null;
    }
    if (!resp.ok) return null;
    return resp.json();
  }).then(function(data) {
    if (!data || !externalDeviceId) return;
    sdkIsPlaying = data.is_playing;
    sdkCurrentPosition = data.progress_ms || 0;
    sdkDuration = (data.item && data.item.duration_ms) || 0;
    updatePlayPauseButtons();
    updateProgressBars();
  }).catch(function() {});
}

function startExternalPolling() {
  stopExternalPolling();
  pollExternalState(); // immediate first poll so duration/position are available right away
  externalPollInterval = setInterval(pollExternalState, 1000);
}

function stopExternalPolling() {
  if (externalPollInterval) {
    clearInterval(externalPollInterval);
    externalPollInterval = null;
  }
}

function showPlayerError(msg) {
  var e1 = document.getElementById('sdk-error-listening');
  var e2 = document.getElementById('sdk-error-revealed');
  if (e1) e1.textContent = msg;
  if (e2) e2.textContent = msg;
}

function clearPlayerError() {
  showPlayerError('');
}

// ==================== DEVICE PICKER ====================
async function fetchDevices() {
  if (!isTokenValid()) return { devices: [], activeDevice: null };
  try {
    var headers = { 'Authorization': 'Bearer ' + sdkToken };
    var [devResp, playerResp] = await Promise.all([
      fetch('https://api.spotify.com/v1/me/player/devices', { headers: headers }),
      fetch('https://api.spotify.com/v1/me/player', { headers: headers })
    ]);

    var devices = [];
    if (devResp.ok) {
      var devData = await devResp.json();
      devices = devData.devices || [];
    }

    // Get the currently active device from /me/player (may have null id, e.g. Sonos)
    var activeDevice = null;
    if (playerResp.ok && playerResp.status !== 204) {
      try {
        var playerData = await playerResp.json();
        if (playerData && playerData.device) {
          activeDevice = playerData.device;
          // If it has an id and is missing from the list, merge it in
          if (activeDevice.id) {
            var found = devices.some(function(d) { return d.id === activeDevice.id; });
            if (!found) {
              devices.push({
                id: activeDevice.id,
                name: activeDevice.name,
                type: activeDevice.type,
                is_active: true
              });
            }
          }
        }
      } catch (e) {}
    }

    return { devices: devices, activeDevice: activeDevice };
  } catch (e) {
    return { devices: [], activeDevice: null };
  }
}

async function showDevicePicker() {
  document.getElementById('device-picker-modal').classList.remove('hidden');
  await refreshDeviceList();
}

async function refreshDeviceList() {
  var list = document.getElementById('device-picker-list');
  list.textContent = 'Loading devices...';

  var result = await fetchDevices();
  var devices = result.devices;
  var activeDevice = result.activeDevice;
  list.textContent = '';

  if (devices.length === 0 && !activeDevice) {
    list.innerHTML = '<p style="color:var(--text-dim);font-size:13px">No devices found. Make sure Spotify is open on at least one device.</p>';
    appendRefreshButton(list);
    return;
  }

  // Merge duplicate HitStar Player entries (SDK device may appear twice)
  var seen = {};
  var merged = [];
  devices.forEach(function(d) {
    if (d.name === 'HitStar Player' || d.id === sdkDeviceId) {
      if (!seen['__hitstar__']) {
        seen['__hitstar__'] = true;
        merged.push({ id: sdkDeviceId || d.id, name: 'HitStar Player', type: d.type, is_active: d.is_active, _isSDK: true });
      }
    } else {
      merged.push(d);
    }
  });

  // Sort: selected first, then active, then alphabetical
  merged.sort(function(a, b) {
    var aSelected = a._isSDK ? !externalDeviceId : a.id === externalDeviceId;
    var bSelected = b._isSDK ? !externalDeviceId : b.id === externalDeviceId;
    if (aSelected !== bSelected) return aSelected ? -1 : 1;
    if (a.is_active !== b.is_active) return a.is_active ? -1 : 1;
    return a.name.localeCompare(b.name);
  });

  // "Current Spotify device" option â€” plays on whatever Spotify is currently using.
  // Only show if the active device is NOT restricted (restricted = Spotify Web API can't control it).
  var isRestricted = activeDevice && activeDevice.is_restricted;
  if (activeDevice && !isRestricted) {
    var activeItem = document.createElement('button');
    activeItem.className = 'device-item';
    if (externalDeviceId === '__active__') activeItem.classList.add('selected');
    var activeName = activeDevice.name || 'Unknown device';
    var activeIcon = activeDevice.type === 'Speaker' ? '\uD83D\uDD0A'
      : activeDevice.type === 'Smartphone' ? '\uD83D\uDCF1'
      : activeDevice.type === 'Computer' ? '\uD83D\uDCBB'
      : activeDevice.type === 'TV' ? '\uD83D\uDCFA'
      : activeDevice.type === 'CastVideo' ? '\uD83D\uDCFA'
      : activeDevice.type === 'Game_console' ? '\uD83C\uDFAE'
      : activeDevice.type === 'Automobile' ? '\uD83D\uDE97'
      : '\uD83C\uDFB5';
    activeItem.innerHTML = activeIcon + ' Current Spotify device' +
      '<span style="display:block;font-size:12px;color:var(--text-dim);margin-top:2px">' + activeName + '</span>';
    activeItem.addEventListener('click', function() {
      selectDevice('__active__', activeName);
      closeDevicePicker();
    });
    list.appendChild(activeItem);
    var sep = document.createElement('div');
    sep.style.cssText = 'border-top:1px solid #333;margin:10px 0;';
    list.appendChild(sep);
  } else if (isRestricted) {
    var notice = document.createElement('div');
    notice.style.cssText = 'padding:10px 12px;background:rgba(231,76,60,0.1);border:1px solid rgba(231,76,60,0.3);border-radius:8px;margin-bottom:10px;font-size:12px;color:var(--text-dim);';
    notice.innerHTML = '\uD83D\uDD0A <strong style="color:var(--text)">' + activeDevice.name + '</strong> is playing but can\u2019t be controlled from web apps (Spotify restriction). Choose a device below \u2014 HitStar will transfer playback to it.';
    list.appendChild(notice);
  }

  merged.forEach(function(d) {
    var item = document.createElement('button');
    item.className = 'device-item';
    var isSelected = d._isSDK
      ? (!externalDeviceId)
      : (externalDeviceId !== '__active__' && d.id === externalDeviceId);
    if (isSelected) item.classList.add('selected');

    var icon = d.type === 'Speaker' ? '\uD83D\uDD0A'
      : d.type === 'Smartphone' ? '\uD83D\uDCF1'
      : d.type === 'Computer' ? '\uD83D\uDCBB'
      : d.type === 'TV' ? '\uD83D\uDCFA'
      : d.type === 'CastVideo' ? '\uD83D\uDCFA'
      : d.type === 'Game_console' ? '\uD83C\uDFAE'
      : d.type === 'Automobile' ? '\uD83D\uDE97'
      : '\uD83C\uDFB5';

    var label = icon + ' ' + d.name;
    if (d._isSDK) label += ' (this browser)';
    item.textContent = label;

    item.addEventListener('click', function() {
      selectDevice(d._isSDK ? null : d.id, d.name);
      closeDevicePicker();
    });
    list.appendChild(item);
  });

  appendRefreshButton(list);
}

function appendRefreshButton(container) {
  var refreshBtn = document.createElement('button');
  refreshBtn.className = 'btn btn-sm btn-outline';
  refreshBtn.style.cssText = 'margin-top:12px;width:100%;';
  refreshBtn.textContent = '\u21BB Refresh devices';
  refreshBtn.addEventListener('click', function() { refreshDeviceList(); });
  container.appendChild(refreshBtn);
}

function selectDevice(deviceId, name) {
  externalDeviceId = deviceId;
  externalDeviceName = deviceId ? name : '';

  // Update labels
  var label = document.getElementById('current-device-name');
  if (label) label.textContent = deviceId ? name : 'HitStar Player (this browser)';
  var gameLabel = document.getElementById('game-device-name');
  if (gameLabel) gameLabel.textContent = deviceId ? name : '';

  if (deviceId) {
    // Transfer playback to the selected device (skip for __active__ â€” already playing there)
    if (deviceId !== '__active__' && sdkToken) {
      fetch('https://api.spotify.com/v1/me/player', {
        method: 'PUT',
        headers: {
          'Authorization': 'Bearer ' + sdkToken,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ device_ids: [deviceId], play: sdkIsPlaying })
      }).then(function(resp) {
        if (!resp.ok) showToast('Failed to transfer playback to ' + name, 'error');
      }).catch(function() {
        showToast('Failed to transfer playback to ' + name, 'error');
      });
    }
    // External device: poll for state, stop SDK progress tracking
    stopProgressTracking();
    startExternalPolling();
  } else {
    // Back to SDK player: stop polling, transfer playback back
    stopExternalPolling();
    if (sdkDeviceId && sdkToken) {
      transferToHitStar();
    }
  }
}

function closeDevicePicker() {
  document.getElementById('device-picker-modal').classList.add('hidden');
}

// ==================== INIT ====================
function init() {
  loadSettings();

  // Restore SDK token and refresh token from storage
  var storedToken = localStorage.getItem(SDK_TOKEN_KEY);
  var storedExpiry = parseInt(localStorage.getItem(SDK_TOKEN_EXPIRY_KEY) || '0');
  var storedRefresh = localStorage.getItem(SDK_REFRESH_TOKEN_KEY);
  if (storedRefresh) sdkRefreshToken = storedRefresh;
  if (storedToken && Date.now() < storedExpiry) {
    sdkToken = storedToken;
    sdkTokenExpiry = storedExpiry;
    scheduleTokenRefresh();
    if (window.Spotify && window.Spotify.Player) {
      initializeSDKPlayer();
    }
  } else if (storedRefresh) {
    // Token expired but we have a refresh token â€” try to refresh now
    refreshAccessToken().then(function(ok) {
      if (ok && window.Spotify && window.Spotify.Player && !sdkReady) {
        initializeSDKPlayer();
      }
    });
  }

  // Check for Spotify OAuth PKCE callback (?code=...)
  var urlParams = new URLSearchParams(window.location.search);
  var authCode = urlParams.get('code');
  if (authCode) {
    history.replaceState(null, '', window.location.pathname);
    pendingAction = localStorage.getItem(PENDING_KEY) || 'sdk';
    localStorage.removeItem(PENDING_KEY);
    handleAuthCode(authCode, pendingAction);
  }

  // Also handle legacy implicit grant callback (#access_token=...) for backwards compat
  var hash = window.location.hash;
  if (hash.includes('access_token')) {
    var hparams = new URLSearchParams(hash.substring(1));
    var htoken = hparams.get('access_token');
    var hexpiresIn = parseInt(hparams.get('expires_in') || '3600');
    window.location.hash = '';
    history.replaceState(null, '', window.location.pathname);
    pendingAction = localStorage.getItem(PENDING_KEY) || 'sdk';
    localStorage.removeItem(PENDING_KEY);
    applyToken(htoken, hexpiresIn, pendingAction);
  }

  // Ensure hardcoded client ID is always set
  gameSettings.spotifyClientId = SPOTIFY_CLIENT_ID;

  updateHomeConnectUI();

  // Check for saved game to resume (only on homepage, not during a game)
  if (!gameState.active) {
    var savedGame = loadGameSave();
    if (savedGame && savedGame.active && savedGame.players && savedGame.players.length > 0) {
      showResumeBanner(savedGame);
    }
  }
}

// Exchange PKCE auth code for token, then apply it
async function handleAuthCode(code, action) {
  showToast('Connecting to Spotify...', 'success', 10000);
  var data = await exchangeCodeForToken(code);
  if (!data || !data.access_token) {
    showToast('Failed to connect to Spotify. Please try again.', 'error');
    return;
  }
  // Store refresh token from PKCE exchange
  if (data.refresh_token) {
    sdkRefreshToken = data.refresh_token;
    localStorage.setItem(SDK_REFRESH_TOKEN_KEY, sdkRefreshToken);
  }
  applyToken(data.access_token, data.expires_in || 3600, action);
}

// Store token and initialize SDK + trigger pending action
function applyToken(token, expiresIn, action) {
  sdkToken = token;
  sdkTokenExpiry = Date.now() + expiresIn * 1000;
  localStorage.setItem(SDK_TOKEN_KEY, sdkToken);
  localStorage.setItem(SDK_TOKEN_EXPIRY_KEY, String(sdkTokenExpiry));
  scheduleTokenRefresh();

  if (window.Spotify && window.Spotify.Player && !sdkReady) {
    initializeSDKPlayer();
  }

  if (action === 'lookup') {
    spotifyToken = token;
    spotifyLookupWithToken();
  }
}

// ==================== SETTINGS DATA ====================
function loadSettings() {
  try {
    var stored = localStorage.getItem(SETTINGS_KEY);
    if (stored) {
      var parsed = JSON.parse(stored);
      for (var k in parsed) {
        if (parsed.hasOwnProperty(k)) gameSettings[k] = parsed[k];
      }
    }
  } catch (e) {}
  // Always use hardcoded client ID
  gameSettings.spotifyClientId = SPOTIFY_CLIENT_ID;
}

function saveSetting(key, value) {
  gameSettings[key] = value;
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(gameSettings));
}

// ==================== NAVIGATION ====================
function showScreen(id) {
  // If navigating away from the game board while a game is active, end it cleanly
  if (gameState.active && id !== 'game-board') {
    quitGame();
  }
  document.querySelectorAll('.screen').forEach(function(s) { s.classList.remove('active'); });
  document.getElementById(id).classList.add('active');
  document.querySelectorAll('.nav button').forEach(function(b) { b.classList.remove('active'); });
  var navBtn = document.getElementById('nav-' + id);
  if (navBtn) navBtn.classList.add('active');

}

// ==================== PLAYBACK ====================

async function playSong(song) {
  currentSong = song;
  clearPlayerError();
  resetProgressBars();

  document.getElementById('np-category').textContent = song.category || 'Unknown';
  document.getElementById('np-category-rev').textContent = song.category || 'Unknown';
  document.getElementById('np-artist').textContent = song.artist;
  document.getElementById('np-title').textContent = song.title;
  document.getElementById('np-year').textContent = song.year || '????';

  document.getElementById('np-listening').style.display = '';
  document.getElementById('np-revealed').style.display = 'none';
  document.getElementById('btn-reveal').style.display = '';
  document.getElementById('btn-reopen-spotify').style.display = 'none';

  showScreen('now-playing');

  if (externalDeviceId || (sdkReady && sdkDeviceId)) {
    // Will auto-resolve spotifyId via Search API if missing
    var success = await startSDKPlayback(song);
    if (success) {
      document.getElementById('np-status-text').textContent = 'Now playing';
      document.getElementById('np-status-sub').textContent = 'Listen and guess the song!';
      return;
    }
  }

  if (!sdkReady && !externalDeviceId) {
    document.getElementById('np-status-text').textContent = 'Spotify not connected';
    document.getElementById('np-status-sub').textContent = 'Go to Settings to connect your Spotify account';
    showPlayerError('Connect Spotify in Settings to enable playback');
  } else if (!song.spotifyId) {
    document.getElementById('np-status-text').textContent = 'Track not found';
    document.getElementById('np-status-sub').textContent = 'Could not find this song on Spotify';
    showPlayerError('Song not found on Spotify');
  } else {
    document.getElementById('np-status-text').textContent = 'Playback failed';
    document.getElementById('np-status-sub').textContent = 'Could not start playback for this track';
    showPlayerError('Playback failed - try another track');
  }
}

// Look up a Spotify track ID via the Search API.
// Caches the result on the song object and in localStorage.
async function searchSpotifyId(song) {
  if (!isTokenValid() || !song.artist || !song.title) return null;
  try {
    var q = encodeURIComponent('track:' + song.title + ' artist:' + song.artist);
    var resp = await spotifyFetch('https://api.spotify.com/v1/search?q=' + q + '&type=track&limit=1');
    if (!resp.ok) return null;
    var data = await resp.json();
    var tracks = data.tracks && data.tracks.items;
    if (tracks && tracks.length > 0) {
      var track = tracks[0];
      // Basic name matching: verify artist/title reasonably match before caching
      var returnedArtists = (track.artists || []).map(function(a) { return a.name.toLowerCase(); }).join(' ');
      var returnedTitle = (track.name || '').toLowerCase();
      var wantArtist = song.artist.toLowerCase();
      var wantTitle = song.title.toLowerCase();
      if (returnedArtists.indexOf(wantArtist) === -1 && wantArtist.indexOf(returnedArtists.split(' ')[0]) === -1 &&
          returnedTitle.indexOf(wantTitle) === -1 && wantTitle.indexOf(returnedTitle) === -1) {
        return null;
      }
      var newId = track.id;
      song.spotifyId = newId;
      // Grab album art (prefer 300px, fall back to largest)
      if (track.album && track.album.images && track.album.images.length > 0) {
        song.albumArt = (track.album.images[1] || track.album.images[0]).url;
      }
      return newId;
    }
  } catch (e) { /* ignore */ }
  return null;
}

async function playTrackById(trackId) {
  // __active__ means "use whatever Spotify is currently playing on" (no device_id needed)
  var url = 'https://api.spotify.com/v1/me/player/play';
  if (externalDeviceId && externalDeviceId !== '__active__') {
    url += '?device_id=' + externalDeviceId;
  } else if (!externalDeviceId && sdkDeviceId) {
    url += '?device_id=' + sdkDeviceId;
  }
  var resp = await spotifyFetch(url, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ uris: ['spotify:track:' + trackId] })
  });
  return resp;
}

async function startSDKPlayback(song) {
  if (!isTokenValid()) return false;
  if (!externalDeviceId && (!sdkReady || !sdkDeviceId)) return false;

  // Always verify the track ID via search to catch wrong-song mappings.
  // searchSpotifyId updates song.spotifyId and caches the result.
  if (song.artist && song.title) {
    await searchSpotifyId(song);
  }

  if (!song.spotifyId) return false;

  try {
    // If using SDK player and playback was transferred away, reclaim it first
    if (!externalDeviceId && sdkDeviceLost) {
      await transferToHitStar();
    }

    var resp = await playTrackById(song.spotifyId);

    // If SDK device isn't active (transferred away), reclaim and retry
    if (!externalDeviceId && (resp.status === 404 || resp.status === 502)) {
      var transferred = await transferToHitStar();
      if (transferred) {
        resp = await playTrackById(song.spotifyId);
      }
    }

    if (resp.status === 204 || resp.status === 200) return true;

    if (resp.status === 401) {
      sdkToken = null;
      sdkTokenExpiry = 0;
      localStorage.removeItem(SDK_TOKEN_KEY);
      localStorage.removeItem(SDK_TOKEN_EXPIRY_KEY);
      sdkReady = false;
      if (sdkPlayer) sdkPlayer.disconnect();
      updateSDKStatus('Session expired');
      updateHomeConnectUI();
      showGameReconnectBtn(true);
      showToast('Spotify session expired. Please reconnect.', 'error');
      return false;
    }

    // 403 from restricted device (e.g. Sonos) â€” try to reclaim HitStar Player
    if (resp.status === 403) {
      var errBody = null;
      try { errBody = await resp.json(); } catch (e) {}
      if (errBody && errBody.error && /restricted/i.test(errBody.error.message)) {
        showToast('Restricted device â€” switching to HitStar Player...', 'error');
        // Reset to SDK mode and reclaim
        externalDeviceId = null;
        externalDeviceName = '';
        stopExternalPolling();
        var labelEl = document.getElementById('current-device-name');
        if (labelEl) labelEl.textContent = 'HitStar Player (this browser)';
        var gameLabelEl = document.getElementById('game-device-name');
        if (gameLabelEl) gameLabelEl.textContent = '';
        var transferred = await transferToHitStar();
        if (transferred) {
          var retryResp = await playTrackById(song.spotifyId);
          if (retryResp.status === 204 || retryResp.status === 200) return true;
        }
        return false;
      }
      showToast('Track not available on Spotify', 'error');
      return false;
    }

    if (resp.status === 404) {
      showToast('Track not available on Spotify', 'error');
      return false;
    }

    return false;
  } catch (e) {
    return false;
  }
}

function getSpotifyUrl(song) {
  if (song.spotifyId) {
    return 'https://open.spotify.com/track/' + song.spotifyId;
  }
  var query = encodeURIComponent(song.artist + ' ' + song.title);
  return 'https://open.spotify.com/search/' + query;
}

function openCurrentInSpotify() {
  if (!currentSong) return;
  window.open(getSpotifyUrl(currentSong), '_blank');
}

function revealSong() {
  document.getElementById('np-listening').style.display = 'none';
  document.getElementById('np-revealed').style.display = '';
  document.getElementById('btn-reveal').style.display = 'none';
  document.getElementById('btn-reopen-spotify').style.display = '';
}

function playRandom() {
  if (!sessionPlaylist || sessionPlaylist.tracks.length === 0) {
    alert('No playlist selected! Choose a playlist in the Playlists tab first.');
    return;
  }

  var pool = sessionPlaylist.tracks;
  var idx = Math.floor(Math.random() * pool.length);
  playSong(pool[idx]);
}

// ==================== SPOTIFY AUTH (PKCE) ====================
var PKCE_VERIFIER_KEY = 'hitstar_pkce_verifier';

function generateCodeVerifier() {
  var arr = new Uint8Array(64);
  crypto.getRandomValues(arr);
  return btoa(String.fromCharCode.apply(null, arr))
    .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

async function generateCodeChallenge(verifier) {
  var encoder = new TextEncoder();
  var data = encoder.encode(verifier);
  var digest = await crypto.subtle.digest('SHA-256', data);
  return btoa(String.fromCharCode.apply(null, new Uint8Array(digest)))
    .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

async function requireSpotifyAuth(action) {
  localStorage.setItem(PENDING_KEY, action);
  var verifier = generateCodeVerifier();
  localStorage.setItem(PKCE_VERIFIER_KEY, verifier);
  var challenge = await generateCodeChallenge(verifier);
  var redirectUri = encodeURIComponent(window.location.origin + window.location.pathname);
  var scopes = 'streaming user-read-email user-read-private user-modify-playback-state user-read-playback-state playlist-read-private playlist-read-collaborative';
  var authUrl = 'https://accounts.spotify.com/authorize?client_id=' + SPOTIFY_CLIENT_ID
    + '&response_type=code&redirect_uri=' + redirectUri
    + '&scope=' + encodeURIComponent(scopes)
    + '&code_challenge_method=S256&code_challenge=' + challenge;
  window.location.href = authUrl;
  return true;
}

async function exchangeCodeForToken(code) {
  var verifier = localStorage.getItem(PKCE_VERIFIER_KEY);
  if (!verifier) return null;

  var redirectUri = window.location.origin + window.location.pathname;
  try {
    var resp = await fetch('https://accounts.spotify.com/api/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: 'grant_type=authorization_code&code=' + encodeURIComponent(code)
        + '&redirect_uri=' + encodeURIComponent(redirectUri)
        + '&client_id=' + encodeURIComponent(SPOTIFY_CLIENT_ID)
        + '&code_verifier=' + encodeURIComponent(verifier)
    });
    if (!resp.ok) return null;
    var data = await resp.json();
    // Only delete verifier AFTER successful exchange
    localStorage.removeItem(PKCE_VERIFIER_KEY);
    return data;
  } catch (e) {
    // Network error â€” verifier is preserved so user can retry
    return null;
  }
}

// ==================== SPOTIFY TRACK LOOKUP ====================
function spotifyLookupAll() {
  var missing = songs.filter(function(s) { return !s.spotifyId; });
  if (missing.length === 0) {
    alert('All songs already have Spotify Track IDs!');
    return;
  }
  requireSpotifyAuth('lookup');
}

async function spotifyLookupWithToken() {
  if (!spotifyToken) return;

  var missing = songs.filter(function(s) { return !s.spotifyId; });
  var statusEl = document.getElementById('lookup-status');
  statusEl.textContent = 'Looking up ' + missing.length + ' songs...';
  showScreen('settings');

  var found = 0;
  for (var i = 0; i < missing.length; i++) {
    var s = missing[i];
    statusEl.textContent = 'Looking up ' + (i + 1) + '/' + missing.length + ': ' + s.artist + ' - ' + s.title;

    try {
      var query = encodeURIComponent('track:' + s.title + ' artist:' + s.artist);
      var resp = await fetch('https://api.spotify.com/v1/search?q=' + query + '&type=track&limit=1', {
        headers: { 'Authorization': 'Bearer ' + spotifyToken }
      });

      if (resp.status === 429) {
        var retry = parseInt(resp.headers.get('Retry-After') || '2');
        await new Promise(function(r) { setTimeout(r, retry * 1000); });
        i--; continue;
      }

      if (resp.status === 401) {
        statusEl.textContent = 'Token expired after ' + found + ' lookups. Reconnect to continue.';
        break;
      }

      if (resp.ok) {
        var data = await resp.json();
        if (data.tracks && data.tracks.items && data.tracks.items.length > 0) {
          var idx = songs.indexOf(s);
          if (idx >= 0) {
            songs[idx].spotifyId = data.tracks.items[0].id;
            found++;
          }
        }
      }
    } catch (e) {}

    await new Promise(function(r) { setTimeout(r, 100); });
  }

  if (!statusEl.textContent.includes('Token expired')) {
    statusEl.textContent = 'Done! Found Spotify IDs for ' + found + '/' + missing.length + ' songs.';
  }
  spotifyToken = null;
}

// ==================== GAME BOARD ====================
var gameState = {
  active: false,
  players: [
    { name: 'Player 1', cards: [], tokens: 0 },
    { name: 'Player 2', cards: [], tokens: 0 }
  ],
  currentPlayer: 0,
  currentSong: null,
  discardPile: [],
  phase: 'listening', // listening, placing, revealing, checking
  winCount: 10,
  usedSongIds: [],
  tokenMode: false,
  titleGuess: '',
  challengeActive: -1
};

function showGameSetup() {
  document.getElementById('victory-overlay').classList.add('hidden');
  document.getElementById('setup-p1-name').value = gameState.players[0].name || 'Player 1';
  document.getElementById('setup-p2-name').value = gameState.players[1].name || 'Player 2';
  document.getElementById('game-setup-modal').classList.remove('hidden');
}

function closeGameSetup() {
  document.getElementById('game-setup-modal').classList.add('hidden');
}

function setSetupMode(mode) {
  var classicBtn = document.getElementById('setup-mode-classic');
  var tokenBtn = document.getElementById('setup-mode-token');
  var hint = document.getElementById('setup-mode-hint');
  classicBtn.classList.toggle('active', mode === 'classic');
  tokenBtn.classList.toggle('active', mode === 'token');
  hint.textContent = mode === 'token'
    ? 'Earn tokens by guessing song titles. Spend tokens to buy cards, skip songs, or challenge opponents!'
    : 'Place songs in chronological order. Wrong guesses go to the discard pile.';
}

function startGame() {
  var p1 = document.getElementById('setup-p1-name').value.trim() || 'Player 1';
  var p2 = document.getElementById('setup-p2-name').value.trim() || 'Player 2';
  var winCount = parseInt(document.getElementById('setup-win-count').value) || 10;
  var isTokenMode = document.getElementById('setup-mode-token').classList.contains('active');

  // Pause any existing playback before resetting
  if (sdkIsPlaying) {
    pausePlayback();
  }

  // Clear any lingering DOM elements from previous game
  var gameBody = document.getElementById('game-body');
  if (gameBody) gameBody.textContent = '';
  dismissTitleJudge();
  // Remove any lingering flash/banner overlays
  document.querySelectorAll('.guess-flash, .guess-banner, .card-popout-overlay').forEach(function(el) { el.remove(); });

  gameState = {
    active: true,
    players: [
      { name: p1, cards: [], tokens: 0 },
      { name: p2, cards: [], tokens: 0 }
    ],
    currentPlayer: 0,
    currentSong: null,
    discardPile: [],
    phase: 'listening',
    winCount: winCount,
    usedSongIds: [],
    tokenMode: isTokenMode,
    titleGuess: '',
    challengeActive: -1
  };

  // Clear any saved game and resume banner when starting fresh
  clearGameSave();
  var oldBanner = document.getElementById('resume-banner');
  if (oldBanner) oldBanner.remove();

  closeGameSetup();
  document.getElementById('victory-overlay').classList.add('hidden');

  // Hide bottom nav during game
  document.querySelector('.nav').style.display = 'none';

  // Show game board screen
  document.querySelectorAll('.screen').forEach(function(s) { s.classList.remove('active'); });
  document.getElementById('game-board').classList.add('active');

  // Reset now-playing bar
  updateNowPlayingBar(null, false);
  setGameStatus('', '');

  renderGameBoard();
  gamePlayNext();
}

function quitGame() {
  gameState.active = false;
  gameState.phase = 'done';
  document.getElementById('victory-overlay').classList.add('hidden');
  document.querySelector('.nav').style.display = '';

  // Remove piles sidebar
  var piles = document.getElementById('game-board').querySelector('.game-piles');
  if (piles) piles.remove();

  // Pause playback
  if (sdkIsPlaying) {
    pausePlayback();
  }

  // Clean up lingering DOM elements
  dismissTitleJudge();
  document.querySelectorAll('.guess-flash, .guess-banner, .card-popout-overlay').forEach(function(el) { el.remove(); });
  // Clear game body to avoid stale DOM
  var gameBody = document.getElementById('game-body');
  if (gameBody) gameBody.textContent = '';

  // Clear saved game
  clearGameSave();

  showScreen('home');
}

// ==================== GAME SAVE/RESTORE ====================
function saveGame() {
  if (!gameState.active) return;
  try {
    var saveData = {
      players: gameState.players,
      currentPlayer: gameState.currentPlayer,
      currentSong: gameState.currentSong,
      discardPile: gameState.discardPile,
      phase: gameState.phase,
      winCount: gameState.winCount,
      usedSongIds: gameState.usedSongIds,
      tokenMode: gameState.tokenMode,
      active: gameState.active,
      savedAt: Date.now()
    };
    localStorage.setItem(GAME_SAVE_KEY, JSON.stringify(saveData));
  } catch (e) {
    showToast('Could not save game â€” storage may be full', 'error');
  }
}

function clearGameSave() {
  localStorage.removeItem(GAME_SAVE_KEY);
}

function loadGameSave() {
  try {
    var stored = localStorage.getItem(GAME_SAVE_KEY);
    if (!stored) return null;
    return JSON.parse(stored);
  } catch (e) {
    return null;
  }
}

function restoreGame(saveData) {
  // Validate saved data structure before restoring
  if (!saveData || !Array.isArray(saveData.players) || saveData.players.length === 0) {
    showToast('Saved game data is invalid â€” starting fresh', 'error', 4000);
    clearGameSave();
    return;
  }
  for (var i = 0; i < saveData.players.length; i++) {
    var p = saveData.players[i];
    if (!p || !p.name || !Array.isArray(p.cards)) {
      showToast('Saved game data is corrupted â€” starting fresh', 'error', 4000);
      clearGameSave();
      return;
    }
  }
  var cp = parseInt(saveData.currentPlayer) || 0;
  if (cp < 0 || cp >= saveData.players.length) cp = 0;

  gameState = {
    active: true,
    players: saveData.players,
    currentPlayer: cp,
    currentSong: saveData.currentSong || null,
    discardPile: Array.isArray(saveData.discardPile) ? saveData.discardPile : [],
    // Always restore to 'waiting' so user can click deck to continue
    phase: 'waiting',
    winCount: saveData.winCount || 10,
    usedSongIds: Array.isArray(saveData.usedSongIds) ? saveData.usedSongIds : [],
    tokenMode: saveData.tokenMode || false,
    titleGuess: '',
    challengeActive: -1
  };

  // Hide bottom nav and show game board
  document.querySelector('.nav').style.display = 'none';
  document.querySelectorAll('.screen').forEach(function(s) { s.classList.remove('active'); });
  document.getElementById('game-board').classList.add('active');

  // Reset now-playing bar (don't try to resume mid-song)
  updateNowPlayingBar(null, false);
  setGameStatus('Game restored - tap deck to continue', '');

  renderGameBoard();
}

function showResumeBanner(saveData) {
  var playerNames = saveData.players.map(function(p) { return p.name; }).join(' vs ');
  var cardCounts = saveData.players.map(function(p) { return p.cards ? p.cards.length : 0; }).join('-');

  var banner = document.createElement('div');
  banner.id = 'resume-banner';
  banner.style.cssText = 'background:var(--surface);border:1px solid var(--accent);border-radius:14px;'
    + 'padding:14px 20px;box-shadow:0 4px 20px rgba(0,0,0,0.5);'
    + 'text-align:center;margin:16px auto;max-width:400px;animation:fadeIn 0.3s ease-out;';

  var text = document.createElement('div');
  text.style.cssText = 'font-size:14px;color:var(--text);margin-bottom:10px;';
  text.textContent = 'Resume: ' + playerNames + ' (' + cardCounts + ' cards)';
  banner.appendChild(text);

  var btns = document.createElement('div');
  btns.style.cssText = 'display:flex;gap:10px;justify-content:center;';

  var resumeBtn = document.createElement('button');
  resumeBtn.className = 'btn btn-sm';
  resumeBtn.textContent = 'Resume Game';
  resumeBtn.addEventListener('click', function() {
    banner.remove();
    restoreGame(saveData);
  });
  btns.appendChild(resumeBtn);

  var dismissBtn = document.createElement('button');
  dismissBtn.className = 'btn btn-sm btn-outline';
  dismissBtn.textContent = 'Dismiss';
  dismissBtn.addEventListener('click', function() {
    banner.remove();
    clearGameSave();
  });
  btns.appendChild(dismissBtn);

  banner.appendChild(btns);
  document.getElementById('home').appendChild(banner);
}

function songDedupeKey(s) {
  return (s.artist + '|' + s.title).toLowerCase().replace(/\s+/g, ' ').trim();
}

function getGameSongPool() {
  var pool = (sessionPlaylist && sessionPlaylist.tracks.length > 0)
    ? sessionPlaylist.tracks
    : [];
  // Filter out yearless songs, already-used songs, and deduplicate by artist+title
  // (same song on different albums has different spotifyIds)
  var seen = {};
  return pool.filter(function(s) {
    // Yearless songs break chronological ordering â€” skip them
    var yr = parseInt(s.year);
    if (!yr || yr <= 0) return false;
    var key = songDedupeKey(s);
    if (seen[key]) return false;
    if (gameState.usedSongIds.indexOf(key) !== -1) return false;
    seen[key] = true;
    return true;
  });
}

async function gamePlayNext() {
  var pool = getGameSongPool();
  if (pool.length === 0) {
    // Reset used songs if pool exhausted
    gameState.usedSongIds = [];
    pool = getGameSongPool();
  }
  if (pool.length === 0) {
    setGameStatus('No songs available!', '');
    return;
  }

  var song = pool[Math.floor(Math.random() * pool.length)];
  gameState.usedSongIds.push(songDedupeKey(song));
  gameState.currentSong = song;
  gameState.phase = 'listening';
  gameState.titleGuess = '';
  gameState.challengeActive = -1;
  dismissTitleJudge();

  setGameStatus('Listen & guess!', '');
  renderGameBoard();

  // Play via SDK or external device
  activePlayingSong = song;
  popoutPlayingSong = null;
  updateNowPlayingBar(song, true);
  if (externalDeviceId || (sdkReady && sdkDeviceId)) {
    resetProgressBars();
    clearPlayerError();
    var success = await startSDKPlayback(song);
    if (!success) {
      setGameStatus('Playback failed - skip?', 'wrong');
    }
  } else {
    setGameStatus('Connect Spotify first!', 'wrong');
  }
  saveGame();
}

function setGameStatus(text, cls) {
  var el = document.getElementById('game-status-text');
  el.textContent = text;
  el.className = 'game-topbar-status' + (cls ? ' ' + cls : '');
}

// ==================== TITLE MATCHING ====================
function normTitle(s) {
  return s.toLowerCase()
    .replace(/\s*[\(\[][^\)\]]*[\)\]]/g, '') // strip (feat. X), [Remaster], etc.
    .replace(/[^a-z0-9\s]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}

function titleMatch(guess, actual) {
  if (!guess || !actual) return false;
  return normTitle(guess) === normTitle(actual);
}

function dismissTitleJudge() {
  var el = document.getElementById('title-judge');
  if (el) el.remove();
}

function showTitleJudgeBadge(playerIdx, autoResult) {
  dismissTitleJudge();

  var badge = document.createElement('div');
  badge.className = 'title-judge ' + (autoResult ? 'matched' : 'no-match');
  badge.id = 'title-judge';

  var verdict = document.createElement('div');
  verdict.className = 'title-judge-verdict';
  verdict.textContent = autoResult ? '+1 token' : 'No match';
  badge.appendChild(verdict);

  var overrideBtn = document.createElement('button');
  overrideBtn.className = 'title-judge-override';
  overrideBtn.textContent = autoResult ? 'Undo token' : 'Award token';
  overrideBtn.addEventListener('click', function() {
    var player = gameState.players[playerIdx];
    if (autoResult) {
      // Undo: take back the token
      if (player.tokens > 0) {
        player.tokens -= 1;
        showToast('Token removed (' + player.tokens + '/' + TOKEN_MAX + ')', 'error', 2000);
      }
    } else {
      // Award: give token
      if (player.tokens < TOKEN_MAX) {
        player.tokens += 1;
        showToast('+1 token (' + player.tokens + '/' + TOKEN_MAX + ')', 'success', 2000);
      }
    }
    badge.remove();
    renderGameBoard();
  });
  badge.appendChild(overrideBtn);

  document.body.appendChild(badge);
}

function computeCardSize() {
  var body = document.getElementById('game-body');
  if (!body) return;
  var cs = getComputedStyle(body);
  var paddingLR = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
  // Content width = inner width minus all padding (includes sidebar reservation)
  var availableWidth = body.clientWidth - paddingLR;
  var maxCards = 2; // minimum: 2 slots
  for (var i = 0; i < gameState.players.length; i++) {
    var count = gameState.players[i].cards.length + 2; // cards + placement slots
    if (count > maxCards) maxCards = count;
  }
  var gap = 6;
  var cardWidth = Math.floor(availableWidth / maxCards) - gap;
  cardWidth = Math.max(90, Math.min(160, cardWidth));
  var tier, cardH;
  if (cardWidth >= 140) { tier = 'large'; cardH = 210; }
  else if (cardWidth >= 110) { tier = 'medium'; cardH = 150; }
  else { tier = 'small'; cardWidth = 90; cardH = 110; }
  // Set on #game-board so both game-body and the fixed piles sidebar inherit
  var board = document.getElementById('game-board');
  board.style.setProperty('--card-w', cardWidth + 'px');
  board.style.setProperty('--card-h', cardH + 'px');
  body.classList.remove('card-size-small', 'card-size-medium', 'card-size-large');
  body.classList.add('card-size-' + tier);
}

function renderGameBoard() {
  // Don't re-render while victory overlay is showing â€” prevents race conditions
  // with resize events and async animation code corrupting the board
  if (gameState.phase === 'done') return;
  var body = document.getElementById('game-body');
  body.textContent = '';
  // Remove previous piles sidebar if any
  var oldPiles = document.getElementById('game-board').querySelector('.game-piles');
  if (oldPiles) oldPiles.remove();
  computeCardSize();

  for (var p = 0; p < gameState.players.length; p++) {
    var player = gameState.players[p];
    var isActive = (p === gameState.currentPlayer && gameState.phase !== 'done');

    var row = document.createElement('div');
    row.className = 'player-row player-' + p + (isActive ? ' active-turn' : '');

    // Header
    var header = document.createElement('div');
    header.className = 'player-row-header';
    var nameEl = document.createElement('span');
    nameEl.className = 'player-row-name';
    nameEl.textContent = player.name;
    if (isActive) {
      var star = document.createElement('span');
      star.className = 'star';
      star.textContent = '\u2605';
      nameEl.appendChild(star);
    }
    header.appendChild(nameEl);
    // Token counter badge
    if (gameState.tokenMode) {
      var tokenBadge = document.createElement('span');
      tokenBadge.className = 'player-token-count';
      tokenBadge.textContent = '\uD83E\uDE99 ' + player.tokens;
      header.appendChild(tokenBadge);
    }
    var scoreEl = document.createElement('span');
    scoreEl.className = 'player-row-score';
    scoreEl.textContent = player.cards.length + '/' + gameState.winCount;
    // Challenge buzzer for non-active player during listening phase
    if (gameState.tokenMode && !isActive && gameState.phase === 'listening' && player.tokens >= TOKEN_COST_CHALLENGE) {
      var buzzer = document.createElement('button');
      buzzer.className = 'challenge-buzzer buzzer-p' + p + (gameState.challengeActive === p ? ' buzzer-active' : '');
      buzzer.textContent = gameState.challengeActive === p ? 'Challenging!' : 'Challenge';
      (function(pIdx) {
        buzzer.addEventListener('click', function() {
          gameState.challengeActive = gameState.challengeActive === pIdx ? -1 : pIdx;
          renderGameBoard();
        });
      })(p);
      header.appendChild(buzzer);
    }
    header.appendChild(scoreEl);
    row.appendChild(header);

    // Token controls for active player during listening phase
    if (gameState.tokenMode && isActive && gameState.phase === 'listening') {
      var tokenControls = document.createElement('div');
      tokenControls.className = 'token-controls';
      var guessInput = document.createElement('input');
      guessInput.type = 'text';
      guessInput.className = 'token-guess-input';
      guessInput.placeholder = 'Guess the song title\u2026';
      guessInput.value = gameState.titleGuess;
      guessInput.id = 'token-guess-input';
      guessInput.addEventListener('input', function(e) {
        gameState.titleGuess = e.target.value;
      });
      tokenControls.appendChild(guessInput);

      var actionsRow = document.createElement('div');
      actionsRow.className = 'token-actions-row';
      var buyBtn = document.createElement('button');
      buyBtn.className = 'btn token-buy-btn';
      buyBtn.textContent = 'Buy Card (' + TOKEN_COST_BUY + '\uD83E\uDE99)';
      buyBtn.disabled = player.tokens < TOKEN_COST_BUY;
      (function(pIdx) {
        buyBtn.addEventListener('click', function() { tokenBuyCard(pIdx); });
      })(p);
      actionsRow.appendChild(buyBtn);

      var skipBtn = document.createElement('button');
      skipBtn.className = 'btn token-skip-btn';
      skipBtn.textContent = 'Skip (' + TOKEN_COST_SKIP + '\uD83E\uDE99)';
      skipBtn.disabled = player.tokens < TOKEN_COST_SKIP;
      (function(pIdx) {
        skipBtn.addEventListener('click', function() { tokenSkipCard(pIdx); });
      })(p);
      actionsRow.appendChild(skipBtn);

      tokenControls.appendChild(actionsRow);
      row.appendChild(tokenControls);
    }

    // Card row
    var cardRow = document.createElement('div');
    cardRow.className = 'card-row';

    if (isActive) {
      // Show placement slots interspersed with cards
      if (player.cards.length === 0) {
        var emptySlot = createPlacementSlot(p, 0, true);
        cardRow.appendChild(emptySlot);
      } else {
        // Slot before first card
        cardRow.appendChild(createPlacementSlot(p, 0, false));
        for (var c = 0; c < player.cards.length; c++) {
          cardRow.appendChild(createGameCard(player.cards[c], p));
          cardRow.appendChild(createPlacementSlot(p, c + 1, false));
        }
      }
    } else {
      // Non-active player: just show cards
      if (player.cards.length === 0) {
        var emptyMsg = document.createElement('div');
        emptyMsg.style.cssText = 'color:var(--text-dim);font-size:13px;padding:10px;';
        emptyMsg.textContent = 'No cards yet';
        cardRow.appendChild(emptyMsg);
      } else {
        for (var c2 = 0; c2 < player.cards.length; c2++) {
          cardRow.appendChild(createGameCard(player.cards[c2], p));
        }
      }
    }

    row.appendChild(cardRow);
    body.appendChild(row);
  }

  // Piles container (deck + discard side by side)
  var pilesContainer = document.createElement('div');
  pilesContainer.className = 'game-piles';

  // --- Card Deck ---
  var deck = document.createElement('div');
  deck.className = 'deck-visual';
  var deckCard = document.createElement('div');
  // During waiting, show next player's color on deck (the card being drawn is theirs)
  var deckPlayerIdx = gameState.phase === 'waiting'
    ? (gameState.currentPlayer + 1) % gameState.players.length
    : gameState.currentPlayer;
  deckCard.className = 'deck-card deck-p' + deckPlayerIdx;
  // Music note icon (face down)
  deckCard.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 3v10.55A4 4 0 1014 17V7h4V3h-6z"/></svg>';
  // Show remaining song count
  var songPool = getGameSongPool();
  var remaining = songPool.length;
  if (remaining > 0) {
    var deckCount = document.createElement('div');
    deckCount.className = 'deck-count';
    deckCount.textContent = remaining;
    deckCard.appendChild(deckCount);
  }
  // During waiting phase: click deck to advance to next turn
  // Otherwise: click to play/resume current song
  if (gameState.phase === 'waiting') {
    deckCard.classList.add('deck-next-turn');
    deckCard.addEventListener('click', function() {
      if (gameState.phase !== 'waiting') return; // prevent double-click race
      gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.players.length;
      gamePlayNext();
    });
  } else {
    deckCard.addEventListener('click', function() {
      if (gameState.currentSong) {
        popoutPlayingSong = null;
        activePlayingSong = gameState.currentSong;
        startSDKPlayback(gameState.currentSong);
        updateNowPlayingBar(gameState.currentSong, true);
      }
    });
  }
  deck.appendChild(deckCard);
  var deckLabel = document.createElement('div');
  deckLabel.className = 'deck-label';
  deckLabel.textContent = gameState.phase === 'waiting' ? 'Next turn' : 'Deck';
  deck.appendChild(deckLabel);
  pilesContainer.appendChild(deck);

  // --- Discard Pile ---
  var pile = document.createElement('div');
  pile.className = 'discard-pile-visual';
  pile.addEventListener('click', function() { showDiscardModal(); });

  if (gameState.discardPile.length === 0) {
    pile.classList.add('discard-pile-empty');
    var emptyCard = document.createElement('div');
    emptyCard.className = 'discard-pile-card-empty';
    emptyCard.textContent = 'Empty';
    pile.appendChild(emptyCard);
  } else {
    var last = gameState.discardPile[gameState.discardPile.length - 1];
    var topCard = document.createElement('div');
    topCard.className = 'discard-pile-card card-p' + last.playerIndex;

    // Album art on discard pile top card (with fallback)
    if (last.song.albumArt) {
      var tcArt = document.createElement('img');
      tcArt.className = 'game-card-art';
      tcArt.alt = '';
      tcArt.src = last.song.albumArt;
      tcArt.onerror = function() {
        var ph = createArtPlaceholder(last.song, last.playerIndex);
        tcArt.parentNode.replaceChild(ph, tcArt);
      };
      topCard.appendChild(tcArt);
    } else {
      var tcPh = createArtPlaceholder(last.song, last.playerIndex);
      topCard.appendChild(tcPh);
      if (sdkToken && last.song.artist && last.song.title) {
        (function(ph, songRef) {
          searchSpotifyId(songRef).then(function() {
            if (songRef.albumArt) {
              var img = document.createElement('img');
              img.className = 'game-card-art';
              img.alt = '';
              img.src = songRef.albumArt;
              img.onload = function() { if (ph.parentNode) ph.parentNode.replaceChild(img, ph); };
              img.onerror = function() {};
            }
          });
        })(tcPh, last.song);
      }
    }

    var tcYear = document.createElement('div');
    tcYear.className = 'game-card-year';
    tcYear.textContent = last.song.year || '????';
    topCard.appendChild(tcYear);

    var tcArtist = document.createElement('div');
    tcArtist.className = 'game-card-artist';
    tcArtist.textContent = last.song.artist;
    topCard.appendChild(tcArtist);

    var tcTitle = document.createElement('div');
    tcTitle.className = 'game-card-title';
    tcTitle.textContent = last.song.title;
    topCard.appendChild(tcTitle);

    if (gameState.discardPile.length > 1) {
      var countBadge = document.createElement('div');
      countBadge.className = 'discard-pile-count';
      countBadge.textContent = gameState.discardPile.length;
      topCard.appendChild(countBadge);
    }

    pile.appendChild(topCard);
  }

  var pileLabel = document.createElement('div');
  pileLabel.className = 'discard-pile-label';
  pileLabel.textContent = 'Discard';
  pile.appendChild(pileLabel);
  pilesContainer.appendChild(pile);

  document.getElementById('game-board').appendChild(pilesContainer);

  // Auto-focus title guess input in token mode
  if (gameState.tokenMode && gameState.phase === 'listening') {
    setTimeout(function() {
      var inp = document.getElementById('token-guess-input');
      if (inp) inp.focus();
    }, 50);
  }
}

function createArtPlaceholder(song, playerIdx) {
  var el = document.createElement('div');
  el.className = 'game-card-art-placeholder game-card-art';
  var colors = ['#e74c3c', '#3498db'];
  el.style.background = 'linear-gradient(135deg, ' + (colors[playerIdx] || '#555') + '33, var(--surface2))';
  el.style.display = 'flex';
  el.style.alignItems = 'center';
  el.style.justifyContent = 'center';
  el.style.borderRadius = '6px';
  el.style.fontSize = '14px';
  el.style.fontWeight = '700';
  el.style.color = 'var(--text-dim)';
  el.textContent = song.year || '?';
  return el;
}

function createGameCard(cardData, playerIdx) {
  var card = document.createElement('div');
  card.className = 'game-card card-p' + playerIdx;

  // Album art with fallback placeholder
  if (cardData.song.albumArt) {
    var artEl = document.createElement('img');
    artEl.className = 'game-card-art';
    artEl.alt = '';
    artEl.src = cardData.song.albumArt;
    artEl.onerror = function() {
      // Replace broken image with colored placeholder
      var placeholder = createArtPlaceholder(cardData.song, playerIdx);
      artEl.parentNode.replaceChild(placeholder, artEl);
    };
    card.appendChild(artEl);
  } else {
    var placeholder = createArtPlaceholder(cardData.song, playerIdx);
    card.appendChild(placeholder);
    // Try to fetch album art in background
    if (sdkToken && cardData.song.artist && cardData.song.title) {
      (function(ph, cd) {
        searchSpotifyId(cd.song).then(function() {
          if (cd.song.albumArt) {
            var img = document.createElement('img');
            img.className = 'game-card-art';
            img.alt = '';
            img.src = cd.song.albumArt;
            img.onerror = function() {}; // keep placeholder on error
            img.onload = function() {
              if (ph.parentNode) ph.parentNode.replaceChild(img, ph);
            };
          }
        });
      })(placeholder, cardData);
    }
  }

  var year = document.createElement('div');
  year.className = 'game-card-year';
  year.textContent = cardData.song.year || '????';
  card.appendChild(year);

  var artist = document.createElement('div');
  artist.className = 'game-card-artist';
  artist.textContent = cardData.song.artist;
  card.appendChild(artist);

  var title = document.createElement('div');
  title.className = 'game-card-title';
  title.textContent = cardData.song.title;
  card.appendChild(title);

  card.addEventListener('click', function() {
    showCardPopout(cardData.song, playerIdx);
  });

  return card;
}

// Card pop-out overlay with play/pause button
var popoutPlayingSong = null; // track which song the popout started
var activePlayingSong = null; // track what's actually playing right now

function updateNowPlayingBar(song, isGameSong) {
  var container = document.getElementById('game-nowplaying');
  var yearEl = document.getElementById('game-nowplaying-year');
  var artistEl = document.getElementById('game-nowplaying-artist');
  var titleEl = document.getElementById('game-nowplaying-title');
  if (!container || !artistEl || !titleEl) return;

  if (!song) {
    if (yearEl) yearEl.textContent = '';
    artistEl.textContent = '';
    titleEl.textContent = '';
    container.className = 'game-topbar-nowplaying obfuscated';
    return;
  }

  if (yearEl) yearEl.textContent = song.year || '????';
  artistEl.textContent = song.artist || '';
  titleEl.textContent = song.title || '';
  container.className = 'game-topbar-nowplaying' + (isGameSong ? ' obfuscated' : '');
}

function showCardPopout(song, playerIdx) {
  // Remove any existing popout
  closeCardPopout();

  var overlay = document.createElement('div');
  overlay.className = 'card-popout-overlay';
  overlay.id = 'card-popout-overlay';

  var popout = document.createElement('div');
  popout.className = 'card-popout popout-p' + playerIdx;

  // Album art
  var artEl = document.createElement('img');
  artEl.className = 'card-popout-art';
  artEl.alt = '';
  artEl.style.display = 'none';
  if (song.albumArt) {
    artEl.src = song.albumArt;
    artEl.style.display = 'block';
  } else if (sdkToken && song.artist && song.title) {
    // Fetch album art on-demand
    searchSpotifyId(song).then(function() {
      if (song.albumArt) {
        artEl.src = song.albumArt;
        artEl.style.display = 'block';
      }
    });
  }
  popout.appendChild(artEl);

  var yearEl = document.createElement('div');
  yearEl.className = 'card-popout-year';
  yearEl.textContent = song.year || '????';
  popout.appendChild(yearEl);

  var artistEl = document.createElement('div');
  artistEl.className = 'card-popout-artist';
  artistEl.textContent = song.artist;
  popout.appendChild(artistEl);

  var titleEl = document.createElement('div');
  titleEl.className = 'card-popout-title';
  titleEl.textContent = song.title;
  popout.appendChild(titleEl);

  // Play/pause button (white circle, black icon â€” Spotify style)
  var playBtn = document.createElement('button');
  playBtn.className = 'card-popout-play';
  playBtn.id = 'popout-play-btn';
  var isThisSongPlaying = popoutPlayingSong === song && sdkIsPlaying;
  playBtn.innerHTML = isThisSongPlaying
    ? '<svg viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>'
    : '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
  playBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    if (popoutPlayingSong === song && sdkIsPlaying) {
      pausePlayback();
      playBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
    } else {
      popoutPlayingSong = song;
      activePlayingSong = song;
      startSDKPlayback(song);
      var isGameSong = gameState.active && gameState.currentSong === song;
      updateNowPlayingBar(song, isGameSong);
      playBtn.innerHTML = '<svg viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>';
    }
  });
  popout.appendChild(playBtn);

  // "Back to current song" button â€” only show during an active game with a current song
  if (gameState.active && gameState.currentSong && gameState.currentSong !== song) {
    var backBtn = document.createElement('button');
    backBtn.className = 'btn btn-sm btn-outline';
    backBtn.style.cssText = 'margin-top:14px;display:block;width:100%;';
    backBtn.textContent = 'Back to current song';
    backBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      popoutPlayingSong = null;
      activePlayingSong = gameState.currentSong;
      startSDKPlayback(gameState.currentSong);
      updateNowPlayingBar(gameState.currentSong, true);
      closeCardPopout();
    });
    popout.appendChild(backBtn);
  }

  overlay.appendChild(popout);

  // Click outside to close
  overlay.addEventListener('click', function(e) {
    if (e.target === overlay) {
      closeCardPopout();
    }
  });

  document.body.appendChild(overlay);
}

function closeCardPopout() {
  var existing = document.getElementById('card-popout-overlay');
  if (existing) existing.remove();
}

function createPlacementSlot(playerIdx, position, isEmpty) {
  var slot = document.createElement('div');
  slot.className = 'placement-slot slot-p' + playerIdx + (isEmpty ? ' empty-row' : '');
  slot.textContent = isEmpty ? '+ Place here' : '+';
  slot.addEventListener('click', function() {
    placeCard(playerIdx, position);
  });
  return slot;
}

// ==================== TOKEN ACTIONS ====================
function findCorrectPosition(player, song) {
  var year = parseInt(song.year) || 0;
  for (var i = 0; i < player.cards.length; i++) {
    if (year <= (parseInt(player.cards[i].song.year) || 0)) return i;
  }
  return player.cards.length;
}

async function tokenBuyCard(playerIdx) {
  if (gameState.phase !== 'listening') return;
  if (playerIdx !== gameState.currentPlayer) return;
  var player = gameState.players[playerIdx];
  if (player.tokens < TOKEN_COST_BUY) return;
  if (!gameState.currentSong) return;

  player.tokens -= TOKEN_COST_BUY;
  var song = gameState.currentSong;
  var pos = findCorrectPosition(player, song);
  player.cards.splice(pos, 0, { song: song });

  showToast('Bought card! ' + song.artist + ' (' + (song.year || '????') + ')', 'success', 2500);
  updateNowPlayingBar(song, false);

  // Check win condition
  if (player.cards.length >= gameState.winCount) {
    renderGameBoard();
    showVictory(playerIdx);
    return;
  }

  // Continue turn with next song (same player)
  gamePlayNext();
}

async function tokenSkipCard(playerIdx) {
  if (gameState.phase !== 'listening') return;
  if (playerIdx !== gameState.currentPlayer) return;
  var player = gameState.players[playerIdx];
  if (player.tokens < TOKEN_COST_SKIP) return;
  if (!gameState.currentSong) return;

  player.tokens -= TOKEN_COST_SKIP;
  var song = gameState.currentSong;
  gameState.discardPile.push({ song: song, playerIndex: playerIdx });

  showToast('Skipped: ' + song.artist, 'success', 2000);

  // Continue turn with next song (same player)
  gamePlayNext();
}

async function placeCard(playerIdx, position) {
  if (gameState.phase !== 'listening') return;
  if (playerIdx !== gameState.currentPlayer) return;
  if (!gameState.currentSong) return;

  // Token mode: evaluate title guess before placing (non-blocking)
  if (gameState.tokenMode && gameState.titleGuess.trim()) {
    var guessResult = titleMatch(gameState.titleGuess, gameState.currentSong.title);
    gameState.titleGuess = '';
    if (guessResult && gameState.players[playerIdx].tokens < TOKEN_MAX) {
      gameState.players[playerIdx].tokens += 1;
    }
    showTitleJudgeBadge(playerIdx, guessResult);
  } else if (gameState.tokenMode) {
    gameState.titleGuess = '';
  }

  gameState.phase = 'placing';
  var song = gameState.currentSong;
  var player = gameState.players[playerIdx];
  var cardData = { song: song };

  // Capture the deck card position before re-render
  var deckCardEl = document.querySelector('.deck-card');
  var deckRect = deckCardEl ? deckCardEl.getBoundingClientRect() : null;

  // Immediately swap deck to next player's color (revealed underneath the flying card)
  if (deckCardEl) {
    var nextPlayerIdx = (gameState.currentPlayer + 1) % gameState.players.length;
    deckCardEl.classList.remove('deck-p' + gameState.currentPlayer);
    deckCardEl.classList.add('deck-p' + nextPlayerIdx);
  }

  // Insert card into data model and re-render
  player.cards.splice(position, 0, cardData);
  renderGameBoard();
  await sleep(50);
  if (!gameState.active) return;

  // Find the newly placed card in the DOM
  var rows = document.querySelectorAll('.player-row');
  var activeRow = rows[playerIdx];
  if (!activeRow) { checkPlacement(playerIdx, position); return; }
  var cardEls = activeRow.querySelectorAll('.game-card');
  var placedCard = cardEls[position];

  if (placedCard && deckRect) {
    var targetRect = placedCard.getBoundingClientRect();

    // Create a flying card clone at the deck's position
    var flyCard = document.createElement('div');
    flyCard.className = 'game-card card-p' + playerIdx;
    flyCard.style.cssText = 'position:fixed;z-index:300;width:' + deckRect.width + 'px;height:' + deckRect.height + 'px;'
      + 'left:' + deckRect.left + 'px;top:' + deckRect.top + 'px;'
      + 'transition:left 0.45s ease-out,top 0.45s ease-out,width 0.45s ease-out,height 0.45s ease-out,transform 0.3s ease-out 0.25s;'
      + 'pointer-events:none;backface-visibility:hidden;display:flex;align-items:center;justify-content:center;';
    // Face-down: show music note
    flyCard.innerHTML = '<svg viewBox="0 0 24 24" style="width:32px;height:32px;opacity:0.4;fill:var(--p' + playerIdx + ')"><path d="M12 3v10.55A4 4 0 1014 17V7h4V3h-6z"/></svg>';
    document.body.appendChild(flyCard);

    // Hide the actual card during flight
    placedCard.style.visibility = 'hidden';

    // Trigger flight
    await sleep(20);
    if (!gameState.active) { flyCard.remove(); return; }
    flyCard.style.left = targetRect.left + 'px';
    flyCard.style.top = targetRect.top + 'px';
    flyCard.style.width = targetRect.width + 'px';
    flyCard.style.height = targetRect.height + 'px';

    // Wait for flight to arrive
    await sleep(460);
    if (!gameState.active) { flyCard.remove(); return; }

    // Flip: rotate to 90deg (hide face-down)
    flyCard.style.transition = 'transform 0.15s ease-in';
    flyCard.style.transform = 'rotateY(90deg)';
    await sleep(160);
    if (!gameState.active) { flyCard.remove(); return; }

    // Swap to revealed content and flip back
    flyCard.remove();
    placedCard.style.visibility = '';
    placedCard.style.transform = 'rotateY(90deg)';
    placedCard.style.transition = 'transform 0.2s ease-out';
    await sleep(20);
    if (!gameState.active) return;
    placedCard.style.transform = 'rotateY(0deg)';
    await sleep(220);
    if (!gameState.active) return;
    placedCard.style.transform = '';
    placedCard.style.transition = '';
  } else if (placedCard) {
    // Fallback: simple flip if no deck rect
    placedCard.style.transform = 'rotateY(90deg)';
    placedCard.style.transition = 'transform 0.3s ease-out';
    await sleep(50);
    if (!gameState.active) return;
    placedCard.style.transform = 'rotateY(0deg)';
    await sleep(350);
    if (!gameState.active) return;
    placedCard.style.transform = '';
    placedCard.style.transition = '';
  }

  if (!gameState.active) return;
  gameState.phase = 'revealing';
  setGameStatus('Placed: ' + song.artist + ' - ' + (song.year || '????'), '');
  // Un-blur now-playing since the song is revealed
  updateNowPlayingBar(song, false);

  await sleep(200);
  if (!gameState.active) return;
  checkPlacement(playerIdx, position);
}

function showGuessResult(isCorrect, text) {
  // Full-screen flash
  var flash = document.createElement('div');
  flash.className = 'guess-flash ' + (isCorrect ? 'correct' : 'wrong');
  document.body.appendChild(flash);
  // Banner
  var banner = document.createElement('div');
  banner.className = 'guess-banner ' + (isCorrect ? 'correct' : 'wrong');
  banner.textContent = text;
  document.body.appendChild(banner);
  setTimeout(function() { flash.remove(); banner.remove(); }, 1500);
}

async function checkPlacement(playerIdx, position) {
  gameState.phase = 'checking';
  var player = gameState.players[playerIdx];
  var cardData = player.cards[position];
  var year = cardData.song.year || 0;

  var leftOk = true, rightOk = true;
  if (position > 0) {
    var leftYear = player.cards[position - 1].song.year || 0;
    if (year < leftYear) leftOk = false;
  }
  if (position < player.cards.length - 1) {
    var rightYear = player.cards[position + 1].song.year || 0;
    if (year > rightYear) rightOk = false;
  }

  var correct = leftOk && rightOk;

  // Find placed card element for animation
  var rows = document.querySelectorAll('.player-row');
  var activeRow = rows[playerIdx];
  var cardEls = activeRow ? activeRow.querySelectorAll('.game-card') : [];
  var placedCard = cardEls[position];

  // Challenge resolution (token mode)
  var challengerIdx = gameState.tokenMode ? gameState.challengeActive : -1;
  var challengerValid = challengerIdx >= 0 && challengerIdx !== playerIdx
    && gameState.players[challengerIdx].tokens >= TOKEN_COST_CHALLENGE;

  if (correct) {
    var correctText = '\u2713 Correct! ' + cardData.song.artist + ' \u2014 ' + (cardData.song.year || '????');
    setGameStatus('Correct! ' + cardData.song.artist + ' (' + (cardData.song.year || '????') + ')', 'correct');
    showGuessResult(true, correctText);
    if (placedCard) {
      placedCard.classList.add('correct-glow');
    }
    // Challenge failed â€” challenger loses token for nothing
    if (challengerValid) {
      gameState.players[challengerIdx].tokens -= TOKEN_COST_CHALLENGE;
      showToast(gameState.players[challengerIdx].name + ' challenged and lost a token!', 'error', 3000);
    }
    await sleep(1200);

    // Check win condition
    if (player.cards.length >= gameState.winCount) {
      showVictory(playerIdx);
      return;
    }
  } else {
    var wrongText = '\u2717 Wrong! ' + cardData.song.artist + ' \u2014 ' + (cardData.song.year || '????');
    setGameStatus('Wrong! ' + cardData.song.artist + ' (' + (cardData.song.year || '????') + ')', 'wrong');
    showGuessResult(false, wrongText);
    if (placedCard) {
      placedCard.classList.add('wrong-shake');
      await sleep(500);
      placedCard.classList.remove('wrong-shake');
      placedCard.classList.add('wrong-slide');
      await sleep(400);
    }
    // Remove card from active player
    player.cards.splice(position, 1);

    // Challenge success â€” challenger gets the card
    if (challengerValid) {
      var challenger = gameState.players[challengerIdx];
      challenger.tokens -= TOKEN_COST_CHALLENGE;
      var cPos = findCorrectPosition(challenger, cardData.song);
      challenger.cards.splice(cPos, 0, { song: cardData.song });
      showToast(challenger.name + ' challenged successfully and gets the card!', 'success', 3000);
      renderGameBoard();
      await sleep(400);
      // Check challenger win condition
      if (challenger.cards.length >= gameState.winCount) {
        showVictory(challengerIdx);
        return;
      }
    } else {
      // Normal discard
      gameState.discardPile.push({ song: cardData.song, playerIndex: playerIdx });
      renderGameBoard();
      await sleep(400);
    }
  }

  gameState.challengeActive = -1;

  // Stay on current player's turn until deck is clicked
  gameState.phase = 'waiting';
  renderGameBoard();
  setGameStatus('', '');
  saveGame();
}

function showVictory(playerIdx) {
  var player = gameState.players[playerIdx];
  document.getElementById('victory-title').textContent = player.name + ' Wins!';
  document.getElementById('victory-subtitle').textContent = 'With ' + player.cards.length + ' cards';
  var victoryCard = document.querySelector('.victory-card');
  victoryCard.classList.remove('victory-p0', 'victory-p1');
  victoryCard.classList.add('victory-p' + playerIdx);
  document.getElementById('victory-overlay').classList.remove('hidden');
  gameState.phase = 'done';

  if (sdkIsPlaying) {
    pausePlayback();
  }
}

function keepPlaying() {
  document.getElementById('victory-overlay').classList.add('hidden');
  gameState.phase = 'waiting';
  gameState.active = true;
  // Disable win limit so players can keep going indefinitely
  gameState.winCount = Infinity;
  renderGameBoard();
  saveGame();
}

function showDiscardModal() {
  var list = document.getElementById('discard-list');
  list.textContent = '';

  if (gameState.discardPile.length === 0) {
    var empty = document.createElement('div');
    empty.style.cssText = 'text-align:center;color:var(--text-dim);padding:20px;';
    empty.textContent = 'No discards yet';
    list.appendChild(empty);
  } else {
    for (var i = gameState.discardPile.length - 1; i >= 0; i--) {
      var d = gameState.discardPile[i];
      var item = document.createElement('div');
      item.className = 'discard-item discard-p' + d.playerIndex;

      var yearEl = document.createElement('div');
      yearEl.className = 'discard-item-year';
      yearEl.textContent = d.song.year || '????';
      item.appendChild(yearEl);

      var info = document.createElement('div');
      info.className = 'discard-item-info';

      var artistEl = document.createElement('div');
      artistEl.className = 'discard-item-artist';
      artistEl.textContent = d.song.artist;
      info.appendChild(artistEl);

      var titleEl = document.createElement('div');
      titleEl.className = 'discard-item-title';
      titleEl.textContent = d.song.title;
      info.appendChild(titleEl);

      var playerEl = document.createElement('div');
      playerEl.className = 'discard-item-player';
      playerEl.textContent = 'Discarded by ' + gameState.players[d.playerIndex].name;
      info.appendChild(playerEl);

      item.appendChild(info);

      // Click to show popout with play button
      (function(song, pIdx) {
        item.addEventListener('click', function() {
          showCardPopout(song, pIdx);
        });
      })(d.song, d.playerIndex);

      list.appendChild(item);
    }
  }

  document.getElementById('discard-modal').classList.remove('hidden');
}

function closeDiscardModal() {
  document.getElementById('discard-modal').classList.add('hidden');
}

// ==================== RULES ====================
function createRulesElement(tag, text, styles) {
  var el = document.createElement(tag);
  if (text) el.textContent = text;
  if (styles) {
    for (var k in styles) el.style[k] = styles[k];
  }
  return el;
}

function showRulesModal(modeFilter) {
  var body = document.getElementById('rules-modal-body');
  body.textContent = '';

  // Classic rules section
  var classicH = createRulesElement('h3', 'Classic Mode');
  classicH.style.cssText = 'font-size:15px;margin-bottom:8px;color:var(--accent)';
  body.appendChild(classicH);

  var classicSteps = [
    'Each turn, a song plays. Listen and decide where it belongs in your timeline.',
    'Click a + slot to place the card in chronological order.',
    'If the year is in the correct position, you keep the card.',
    'If wrong, the card goes to the discard pile.',
    'After each placement, click the deck to pass to the next player.',
    'First player to reach the target number of cards wins!'
  ];
  var ol = document.createElement('ol');
  ol.style.cssText = 'padding-left:20px;font-size:13px;color:var(--text-dim);line-height:1.7;margin-bottom:18px';
  classicSteps.forEach(function(step) {
    var li = document.createElement('li');
    li.textContent = step;
    li.style.marginBottom = '4px';
    ol.appendChild(li);
  });
  body.appendChild(ol);

  // Token rules (shown when modeFilter is 'token' or unset from home)
  if (!modeFilter || modeFilter === 'token') {
    var tokenH = createRulesElement('h3', 'Token Mode');
    tokenH.style.cssText = 'font-size:15px;margin-bottom:8px;color:var(--accent)';
    body.appendChild(tokenH);

    var tokenDesc = createRulesElement('p', 'Builds on Classic rules. Earn tokens by guessing song titles, then spend them on powerful actions.');
    tokenDesc.style.cssText = 'font-size:13px;color:var(--text-dim);margin-bottom:10px';
    body.appendChild(tokenDesc);

    var actions = [
      { name: 'Earn Tokens', desc: 'Type the song title before placing \u2014 correct guess = +1 token (max ' + TOKEN_MAX + ')' },
      { name: 'Buy Card', desc: 'Cost: ' + TOKEN_COST_BUY + ' tokens \u2014 Auto-places the current song correctly in your timeline. Your turn continues.' },
      { name: 'Skip', desc: 'Cost: ' + TOKEN_COST_SKIP + ' token \u2014 Discard the current song and draw a new one. Your turn continues.' },
      { name: 'Challenge', desc: 'Cost: ' + TOKEN_COST_CHALLENGE + ' token \u2014 Press the buzzer before your opponent places. If they place wrong, you get the card! If they place correctly, you lose the token.' }
    ];
    actions.forEach(function(a) {
      var card = document.createElement('div');
      card.className = 'rules-action-card';
      var strong = document.createElement('strong');
      strong.textContent = a.name;
      card.appendChild(strong);
      card.appendChild(document.createElement('br'));
      var cost = document.createElement('span');
      cost.className = 'rules-cost';
      cost.textContent = a.desc;
      card.appendChild(cost);
      body.appendChild(card);
    });
  }

  document.getElementById('rules-modal').classList.remove('hidden');
}

function closeRulesModal() {
  document.getElementById('rules-modal').classList.add('hidden');
}

function showInGameRules() {
  showRulesModal(gameState.tokenMode ? 'token' : 'classic');
}

function sleep(ms) {
  return new Promise(function(resolve) { setTimeout(resolve, ms); });
}

// Override showScreen to handle game board properly
var _originalShowScreen = showScreen;
showScreen = function(id) {
  if (gameState.active && id !== 'game-board') {
    // If quitting game, restore nav
    gameState.active = false;
    document.querySelector('.nav').style.display = '';
  }
  _originalShowScreen(id);
};

// Update game progress bar along with others
var _origUpdateProgressBars = updateProgressBars;
updateProgressBars = function() {
  _origUpdateProgressBars();
  var pct = sdkDuration > 0 ? (sdkCurrentPosition / sdkDuration * 100) : 0;
  var gameBar = document.getElementById('game-progress-bar');
  if (gameBar) gameBar.style.width = pct + '%';
};

// Update game play/pause button along with others
var _origUpdatePlayPause = updatePlayPauseButtons;
updatePlayPauseButtons = function() {
  _origUpdatePlayPause();
  var gameBtn = document.getElementById('game-play-btn');
  if (gameBtn) {
    gameBtn.innerHTML = sdkIsPlaying ? PAUSE_SVG : PLAY_SVG;
  }
};

// ==================== RESIZE HANDLER ====================
var resizeTimer;
window.addEventListener('resize', function() {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(function() {
    if (gameState.active) renderGameBoard();
  }, 150);
});

// ==================== SERVICE WORKER ====================
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(function(err) { console.warn('SW registration failed:', err); });
}

// ==================== STARTUP ====================
init();
</script>
</body>
</html>
