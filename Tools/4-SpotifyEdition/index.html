<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#1a1a2e">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>HitStar - Spotify Edition</title>
<link rel="manifest" href="manifest.json">
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #1a1a2e;
  --surface: #16213e;
  --surface2: #0f3460;
  --accent: #1db954;
  --accent-hover: #1ed760;
  --text: #ffffff;
  --text-dim: #b3b3b3;
  --danger: #e74c3c;
  --card-bg: #222244;
}
html, body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  overflow-x: hidden;
}
.screen { display: none; min-height: 100vh; padding: 16px; padding-bottom: 80px; }
.screen.active { display: flex; flex-direction: column; }
.nav {
  position: fixed; bottom: 0; left: 0; right: 0;
  background: var(--surface); border-top: 1px solid #333;
  display: flex; z-index: 100; padding-bottom: env(safe-area-inset-bottom);
}
.nav button {
  flex: 1; background: none; border: none; color: var(--text-dim);
  padding: 10px 4px; font-size: 11px; cursor: pointer;
  display: flex; flex-direction: column; align-items: center; gap: 4px;
}
.nav button.active { color: var(--accent); }
.nav button svg { width: 24px; height: 24px; }
h1 { font-size: 22px; margin-bottom: 12px; }
h2 { font-size: 18px; margin-bottom: 10px; color: var(--text-dim); }
.btn {
  display: inline-flex; align-items: center; justify-content: center; gap: 8px;
  background: var(--accent); color: #000; border: none; border-radius: 24px;
  padding: 14px 28px; font-size: 16px; font-weight: 600; cursor: pointer;
  transition: background 0.2s;
}
.btn:hover { background: var(--accent-hover); }
.btn:active { transform: scale(0.97); }
.btn-outline {
  background: transparent; color: var(--accent); border: 2px solid var(--accent);
}
.btn-outline:hover { background: rgba(29,185,84,0.1); color: var(--accent); }
.btn-sm { padding: 8px 18px; font-size: 14px; }
.btn-danger { background: var(--danger); }
.btn-danger:hover { background: #c0392b; }
.btn-block { width: 100%; }

/* HOME */
#home { align-items: center; justify-content: center; gap: 20px; text-align: center; }
#home .logo { font-size: 36px; font-weight: 800; letter-spacing: 2px; }
#home .logo span { color: var(--accent); }
#home .subtitle { color: var(--text-dim); font-size: 14px; margin-bottom: 20px; }
.home-actions { display: flex; flex-direction: column; gap: 14px; width: 100%; max-width: 300px; }
.home-actions .btn { font-size: 18px; padding: 18px; }
.song-count { color: var(--text-dim); font-size: 13px; margin-top: 8px; }

/* Connect prompt on home */
.connect-prompt {
  background: var(--surface); border-radius: 16px; padding: 24px; margin-top: 12px;
  width: 100%; max-width: 340px; text-align: center;
}
.connect-prompt p { color: var(--text-dim); font-size: 13px; margin-bottom: 14px; }
.connect-prompt .btn { width: 100%; }
.connect-prompt .setup-fields { margin-top: 14px; text-align: left; }
.connect-prompt .setup-fields label { font-size: 12px; color: var(--text-dim); display: block; margin-bottom: 4px; }
.connect-prompt .setup-fields input { margin-bottom: 10px; }

/* NOW PLAYING */
#now-playing { align-items: center; justify-content: center; gap: 20px; text-align: center; }
.np-card {
  background: var(--card-bg); border-radius: 16px; padding: 30px 20px;
  width: 100%; max-width: 360px;
}
.np-hidden-info { filter: blur(20px); transition: filter 0.5s; user-select: none; }
.np-hidden-info.revealed { filter: none; }
.np-category {
  display: inline-block; background: var(--surface2); padding: 4px 14px;
  border-radius: 12px; font-size: 13px; color: var(--accent); margin-bottom: 14px;
}
.np-artist { font-size: 22px; font-weight: 700; margin-bottom: 6px; }
.np-title { font-size: 16px; color: var(--text-dim); margin-bottom: 16px; }
.np-year {
  font-size: 52px; font-weight: 800; color: var(--accent);
  margin: 10px 0;
}
.np-actions { display: flex; flex-direction: column; gap: 12px; margin-top: 16px; width: 100%; max-width: 360px; }
.np-actions .btn { justify-content: center; }
.reveal-hint { color: var(--text-dim); font-size: 13px; margin-top: 6px; }

/* Custom player controls */
.sdk-player-controls {
  display: flex; align-items: center; gap: 12px; margin: 16px 0 4px;
  width: 100%;
}
.sdk-play-btn {
  background: var(--accent); border: none; border-radius: 50%;
  width: 44px; height: 44px; min-width: 44px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; transition: background 0.2s, transform 0.1s;
}
.sdk-play-btn:hover { background: var(--accent-hover); }
.sdk-play-btn:active { transform: scale(0.93); }
.sdk-play-btn svg { fill: #000; width: 20px; height: 20px; }
.sdk-progress-wrap {
  flex: 1; height: 6px; background: rgba(255,255,255,0.15); border-radius: 3px;
  cursor: pointer; position: relative; overflow: hidden;
}
.sdk-progress-bar {
  height: 100%; background: var(--accent); border-radius: 3px;
  width: 0%; transition: width 0.3s linear;
}
.sdk-player-error {
  color: var(--danger); font-size: 12px; margin-top: 4px; min-height: 16px;
}

/* Session playlist indicator */
.session-playlist-badge {
  display: inline-flex; align-items: center; gap: 6px;
  background: var(--surface2); border-radius: 12px; padding: 4px 12px;
  font-size: 12px; color: var(--accent); margin-top: 4px;
}
.session-playlist-badge button {
  background: none; border: none; color: var(--danger); cursor: pointer;
  font-size: 14px; padding: 0 2px; line-height: 1;
}

/* SONGS MANAGER */
#songs { gap: 14px; }
.songs-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px; }
.category-filters { display: flex; flex-wrap: wrap; gap: 6px; margin: 8px 0; }
.cat-chip {
  background: var(--surface2); border: 1px solid #444; border-radius: 14px;
  padding: 6px 14px; font-size: 13px; color: var(--text-dim); cursor: pointer;
}
.cat-chip.active { background: var(--accent); color: #000; border-color: var(--accent); }
.song-list { display: flex; flex-direction: column; gap: 6px; }
.song-item {
  background: var(--surface); border-radius: 10px; padding: 12px 14px;
  display: flex; justify-content: space-between; align-items: center;
}
.song-item-info { flex: 1; min-width: 0; }
.song-item-info .artist { font-weight: 600; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.song-item-info .title { font-size: 13px; color: var(--text-dim); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.song-item-info .meta { font-size: 11px; color: var(--text-dim); margin-top: 2px; }
.song-item-actions { display: flex; gap: 6px; flex-shrink: 0; margin-left: 8px; }
.icon-btn {
  background: var(--surface2); border: none; color: var(--text-dim);
  width: 34px; height: 34px; border-radius: 50%; cursor: pointer;
  display: flex; align-items: center; justify-content: center; font-size: 16px;
}
.icon-btn:hover { color: var(--text); }
.song-empty { text-align: center; color: var(--text-dim); padding: 40px 20px; }

/* SETTINGS */
#settings { gap: 16px; }
.setting-group { background: var(--surface); border-radius: 12px; padding: 16px; }
.setting-group h3 { font-size: 15px; margin-bottom: 10px; }
.setting-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; }
.setting-row label { color: var(--text-dim); font-size: 14px; }
textarea, input[type="text"], input[type="number"], select {
  background: var(--bg); border: 1px solid #444; border-radius: 8px;
  color: var(--text); padding: 10px; width: 100%; font-size: 14px;
  font-family: inherit;
}
textarea { min-height: 120px; resize: vertical; }
.import-export { display: flex; gap: 10px; margin-top: 10px; }
input[type="file"] { display: none; }

/* MODAL */
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.7);
  display: flex; align-items: center; justify-content: center;
  z-index: 200; padding: 20px;
}
.modal-overlay.hidden { display: none; }
.modal {
  background: var(--surface); border-radius: 16px; padding: 24px;
  width: 100%; max-width: 420px; max-height: 80vh; overflow-y: auto;
}
.modal h2 { margin-bottom: 16px; }
.modal .form-group { margin-bottom: 14px; }
.modal .form-group label { display: block; font-size: 13px; color: var(--text-dim); margin-bottom: 4px; }
.modal-actions { display: flex; gap: 10px; margin-top: 18px; }
.modal-actions .btn { flex: 1; }

/* Now Playing - listening state */
.np-listening-icon {
  margin: 20px 0 10px;
  animation: pulse 2s ease-in-out infinite;
}
@keyframes pulse {
  0%, 100% { opacity: 0.6; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.1); }
}

/* Spotify badge */
.spotify-badge {
  display: inline-flex; align-items: center; gap: 6px;
  color: var(--accent); font-size: 13px;
}
.spotify-badge svg { width: 18px; height: 18px; fill: var(--accent); }

/* Toast notification */
.toast {
  position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
  background: var(--surface); border: 1px solid #444; border-radius: 12px;
  padding: 12px 20px; font-size: 14px; z-index: 300;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4); transition: opacity 0.3s;
  max-width: 90vw; text-align: center;
}
.toast.toast-error { border-color: var(--danger); color: var(--danger); }
.toast.toast-success { border-color: var(--accent); color: var(--accent); }
.toast.toast-hidden { opacity: 0; pointer-events: none; }

/* ==================== GAME BOARD ==================== */
#game-board {
  padding: 0; min-height: 100vh; display: none;
  flex-direction: column; overflow: hidden;
}
#game-board.active { display: flex; }

/* Top bar */
.game-topbar {
  display: flex; align-items: center; gap: 10px;
  background: var(--surface); border-bottom: 1px solid #333;
  padding: 8px 14px; height: 48px; flex-shrink: 0; z-index: 10;
}
.game-topbar .sdk-play-btn {
  width: 32px; height: 32px; min-width: 32px;
}
.game-topbar .sdk-play-btn svg { width: 16px; height: 16px; }
.game-topbar .sdk-progress-wrap { flex: 1; height: 4px; }
.game-topbar-status {
  font-size: 13px; font-weight: 600; white-space: nowrap;
  min-width: 0; overflow: hidden; text-overflow: ellipsis;
}
.game-topbar-status.correct { color: var(--accent); }
.game-topbar-status.wrong { color: var(--danger); }
.game-topbar-nowplaying {
  display: flex; align-items: center; gap: 8px;
  flex: 1; min-width: 0; overflow: hidden;
}
.game-topbar-nowplaying-year {
  font-size: 14px; font-weight: 800; color: var(--accent);
  flex-shrink: 0;
}
.game-topbar-nowplaying-text {
  display: flex; flex-direction: column; justify-content: center;
  min-width: 0; line-height: 1.2;
}
.game-topbar-nowplaying-artist {
  font-size: 13px; font-weight: 600; color: var(--text);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.game-topbar-nowplaying-title {
  font-size: 11px; color: var(--text-dim);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.game-topbar-nowplaying.obfuscated .game-topbar-nowplaying-artist,
.game-topbar-nowplaying.obfuscated .game-topbar-nowplaying-title,
.game-topbar-nowplaying.obfuscated .game-topbar-nowplaying-year {
  filter: blur(6px); user-select: none; pointer-events: none;
}
.game-topbar-btn {
  background: none; border: 1px solid #444; border-radius: 8px;
  color: var(--text-dim); font-size: 13px; padding: 4px 10px;
  cursor: pointer; white-space: nowrap;
}
.game-topbar-btn:hover { color: var(--text); border-color: #666; }

/* Game body (player rows) */
.game-body {
  flex: 1; overflow-y: auto; padding: 16px;
  display: flex; flex-direction: column; gap: 20px;
}

/* Player colors */
:root {
  --p0: #e74c3c; --p0-dim: rgba(231,76,60,0.15); --p0-glow: rgba(231,76,60,0.35);
  --p1: #3498db; --p1-dim: rgba(52,152,219,0.15); --p1-glow: rgba(52,152,219,0.35);
}

/* Player row */
.player-row {
  background: var(--surface); border-radius: 12px; padding: 12px 14px;
  border: 2px solid transparent; transition: all 0.3s ease;
}
.player-row.player-0 { background: linear-gradient(135deg, var(--p0-dim), var(--surface) 60%); border-color: rgba(231,76,60,0.25); }
.player-row.player-1 { background: linear-gradient(135deg, var(--p1-dim), var(--surface) 60%); border-color: rgba(52,152,219,0.25); }
.player-row.player-0.active-turn {
  border-color: var(--p0); box-shadow: 0 0 20px var(--p0-glow), 0 0 40px rgba(231,76,60,0.15);
  transform: scale(1.02); background: linear-gradient(135deg, rgba(231,76,60,0.25), var(--surface) 60%);
}
.player-row.player-1.active-turn {
  border-color: var(--p1); box-shadow: 0 0 20px var(--p1-glow), 0 0 40px rgba(52,152,219,0.15);
  transform: scale(1.02); background: linear-gradient(135deg, rgba(52,152,219,0.25), var(--surface) 60%);
}
.player-row:not(.active-turn) { opacity: 0.55; }
.player-row-header {
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 10px;
}
.player-row-name {
  font-size: 15px; font-weight: 700;
}
.player-row.player-0 .player-row-name { color: #f1948a; }
.player-row.player-1 .player-row-name { color: #85c1e9; }
.player-row-name .star { margin-left: 4px; }
.player-row.player-0 .player-row-name .star { color: var(--p0); }
.player-row.player-1 .player-row-name .star { color: var(--p1); }
.player-row-score {
  font-size: 13px; color: var(--text-dim);
}

/* Card row (horizontal scroll) */
.card-row {
  display: flex; align-items: center; gap: 6px;
  overflow-x: auto; padding: 4px 0 8px;
  scrollbar-width: thin; scrollbar-color: #444 transparent;
}
.card-row::-webkit-scrollbar { height: 4px; }
.card-row::-webkit-scrollbar-thumb { background: #444; border-radius: 2px; }

/* Game card */
.game-card {
  min-width: 90px; max-width: 100px; height: 110px;
  background: var(--card-bg); border-radius: 10px;
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; padding: 8px 6px; cursor: pointer;
  border: 2px solid transparent; transition: border-color 0.2s, box-shadow 0.2s;
  flex-shrink: 0; position: relative; user-select: none;
  perspective: 600px;
}
.game-card.card-p0 { border-color: rgba(231,76,60,0.3); }
.game-card.card-p1 { border-color: rgba(52,152,219,0.3); }
.game-card.card-p0:hover { border-color: rgba(231,76,60,0.6); }
.game-card.card-p1:hover { border-color: rgba(52,152,219,0.6); }
.game-card:active { transform: scale(0.97); }

/* Card pop-out overlay */
.card-popout-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.7);
  display: flex; align-items: center; justify-content: center;
  z-index: 250; padding: 20px; animation: fadeIn 0.15s ease-out;
}
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
.card-popout {
  background: var(--card-bg); border-radius: 20px; padding: 28px 24px;
  min-width: 240px; max-width: 320px; text-align: center;
  border: 3px solid transparent;
  box-shadow: 0 8px 40px rgba(0,0,0,0.5);
  animation: popIn 0.2s ease-out;
}
@keyframes popIn { from { transform: scale(0.85); opacity: 0; } to { transform: scale(1); opacity: 1; } }
.card-popout.popout-p0 { border-color: rgba(231,76,60,0.5); }
.card-popout.popout-p1 { border-color: rgba(52,152,219,0.5); }
.card-popout-art {
  width: 160px; height: 160px; border-radius: 12px; object-fit: cover;
  margin: 0 auto 14px; display: block;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
}
.card-popout-year {
  font-size: 52px; font-weight: 800; line-height: 1.1; margin-bottom: 8px;
}
.card-popout.popout-p0 .card-popout-year { color: var(--p0); }
.card-popout.popout-p1 .card-popout-year { color: var(--p1); }
.card-popout-artist { font-size: 18px; font-weight: 600; color: var(--text); margin-bottom: 4px; }
.card-popout-title { font-size: 15px; color: var(--text-dim); margin-bottom: 20px; }
.card-popout-play {
  width: 56px; height: 56px; border-radius: 50%;
  background: #fff; border: none; cursor: pointer;
  display: inline-flex; align-items: center; justify-content: center;
  transition: transform 0.15s, box-shadow 0.15s;
  box-shadow: 0 2px 12px rgba(0,0,0,0.3);
}
.card-popout-play:hover { transform: scale(1.08); box-shadow: 0 4px 20px rgba(0,0,0,0.4); }
.card-popout-play:active { transform: scale(0.95); }
.card-popout-play svg { width: 24px; height: 24px; fill: #000; }
.game-card-year {
  font-size: 26px; font-weight: 800; color: var(--accent); line-height: 1.1;
}
.game-card.card-p0 .game-card-year { color: var(--p0); }
.game-card.card-p1 .game-card-year { color: var(--p1); }
.game-card-artist {
  font-size: 11px; font-weight: 600; color: var(--text);
  text-align: center; margin-top: 4px;
  max-width: 100%; overflow: hidden; text-overflow: ellipsis;
  white-space: nowrap;
}
.game-card-title {
  font-size: 10px; color: var(--text-dim);
  text-align: center; max-width: 100%;
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}

/* Card flip animation */
.game-card-inner {
  width: 100%; height: 100%;
  display: flex; flex-direction: column; align-items: center;
  justify-content: center;
  transition: transform 0.5s;
  transform-style: preserve-3d;
  position: relative;
}
.game-card.flipping .game-card-inner {
  transform: rotateY(180deg);
}
.game-card-face {
  backface-visibility: hidden;
  position: absolute; width: 100%; height: 100%;
  display: flex; flex-direction: column; align-items: center;
  justify-content: center;
}
.game-card-back {
  transform: rotateY(180deg);
}
.game-card-front {
  background: var(--surface2); border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
}
.game-card-front svg { width: 28px; height: 28px; fill: var(--text-dim); }

/* Placement slot */
.placement-slot {
  min-width: 44px; height: 110px;
  border: 2px dashed rgba(255,255,255,0.2); border-radius: 10px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; flex-shrink: 0;
  font-size: 22px; color: rgba(255,255,255,0.4);
  transition: background 0.2s, border-color 0.2s;
  animation: slotPulse 2s ease-in-out infinite;
}
.placement-slot.slot-p0 { border-color: rgba(231,76,60,0.4); color: rgba(231,76,60,0.6); }
.placement-slot.slot-p1 { border-color: rgba(52,152,219,0.4); color: rgba(52,152,219,0.6); }
.placement-slot.slot-p0:hover { background: rgba(231,76,60,0.1); border-color: var(--p0); color: var(--p0); }
.placement-slot.slot-p1:hover { background: rgba(52,152,219,0.1); border-color: var(--p1); color: var(--p1); }
.placement-slot.empty-row {
  min-width: 120px; font-size: 14px; font-weight: 600;
}
@keyframes slotPulse {
  0%, 100% { opacity: 0.7; }
  50% { opacity: 1; }
}

/* Card animations */
@keyframes glowP0 {
  0% { box-shadow: 0 0 0 rgba(231,76,60,0); }
  50% { box-shadow: 0 0 20px rgba(231,76,60,0.6); }
  100% { box-shadow: 0 0 0 rgba(231,76,60,0); }
}
@keyframes glowP1 {
  0% { box-shadow: 0 0 0 rgba(52,152,219,0); }
  50% { box-shadow: 0 0 20px rgba(52,152,219,0.6); }
  100% { box-shadow: 0 0 0 rgba(52,152,219,0); }
}
@keyframes greenGlow {
  0% { box-shadow: 0 0 0 rgba(29, 185, 84, 0); }
  50% { box-shadow: 0 0 20px rgba(29, 185, 84, 0.6); }
  100% { box-shadow: 0 0 0 rgba(29, 185, 84, 0); }
}
.game-card.correct-glow {
  animation: greenGlow 1s ease-out;
  border-color: var(--accent);
}
.game-card.card-p0.correct-glow { animation: glowP0 1s ease-out; border-color: var(--p0); }
.game-card.card-p1.correct-glow { animation: glowP1 1s ease-out; border-color: var(--p1); }

@keyframes redShake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
  20%, 40%, 60%, 80% { transform: translateX(4px); }
}
@keyframes slideOut {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  100% { opacity: 0; transform: translateY(60px) scale(0.7); }
}
.game-card.wrong-shake {
  animation: redShake 0.5s ease-out;
  border-color: var(--danger);
}
.game-card.wrong-slide {
  animation: slideOut 0.4s ease-in forwards;
}

.game-card.replay-pulse { animation: greenGlow 0.6s ease-out; }
.game-card.card-p0.replay-pulse { animation: glowP0 0.6s ease-out; }
.game-card.card-p1.replay-pulse { animation: glowP1 0.6s ease-out; }

/* Visual discard pile on game board */
.discard-pile-visual {
  display: flex; flex-direction: column; align-items: center; gap: 6px;
  cursor: pointer; margin-top: 16px; align-self: center;
}
.discard-pile-card-empty {
  min-width: 90px; height: 110px; border-radius: 10px;
  border: 2px dashed rgba(255,255,255,0.15);
  display: flex; align-items: center; justify-content: center;
  color: var(--text-dim); font-size: 13px;
}
.discard-pile-card {
  min-width: 90px; max-width: 100px; height: 110px;
  background: var(--card-bg); border-radius: 10px;
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; padding: 8px 6px;
  border: 2px solid transparent; position: relative;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  transition: transform 0.15s;
}
.discard-pile-card:hover { transform: scale(1.05); }
.discard-pile-card.card-p0 { border-color: rgba(231,76,60,0.4); }
.discard-pile-card.card-p1 { border-color: rgba(52,152,219,0.4); }
.discard-pile-card.card-p0 .game-card-year { color: var(--p0); }
.discard-pile-card.card-p1 .game-card-year { color: var(--p1); }
.discard-pile-count {
  position: absolute; top: -8px; right: -8px;
  background: var(--danger); color: #fff; font-size: 11px; font-weight: 700;
  width: 22px; height: 22px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
}
.discard-pile-label {
  font-size: 12px; color: var(--text-dim);
}

/* Deck + discard side by side */
.game-piles {
  display: flex; justify-content: center; gap: 28px;
  margin-top: 16px; align-self: center;
}
.deck-visual {
  display: flex; flex-direction: column; align-items: center; gap: 6px;
  cursor: pointer;
}
.deck-card {
  min-width: 90px; max-width: 100px; height: 110px;
  background: var(--surface2); border-radius: 10px;
  display: flex; align-items: center; justify-content: center;
  border: 2px solid transparent; position: relative;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3), 3px 3px 0 var(--card-bg), 6px 6px 0 var(--surface);
  transition: transform 0.15s;
}
.deck-card:hover { transform: scale(1.05); }
.deck-card.deck-p0 { border-color: rgba(231,76,60,0.5); background: linear-gradient(135deg, rgba(231,76,60,0.15), var(--surface2)); }
.deck-card.deck-p1 { border-color: rgba(52,152,219,0.5); background: linear-gradient(135deg, rgba(52,152,219,0.15), var(--surface2)); }
.deck-card svg { width: 32px; height: 32px; opacity: 0.4; }
.deck-card.deck-p0 svg { fill: var(--p0); }
.deck-card.deck-p1 svg { fill: var(--p1); }
.deck-card.dealing { opacity: 0; transition: opacity 0.2s ease-out; pointer-events: none; }
@keyframes deckPulse {
  0%, 100% { box-shadow: 0 2px 8px rgba(0,0,0,0.3), 3px 3px 0 var(--card-bg), 6px 6px 0 var(--surface), 0 0 0 0 rgba(29,185,84,0); }
  50% { box-shadow: 0 2px 8px rgba(0,0,0,0.3), 3px 3px 0 var(--card-bg), 6px 6px 0 var(--surface), 0 0 16px 4px rgba(29,185,84,0.35); }
}
.deck-card.deck-next-turn { animation: deckPulse 1.5s ease-in-out infinite; cursor: pointer; }
.deck-label { font-size: 12px; color: var(--text-dim); }
.deck-count {
  position: absolute; top: -8px; right: -8px;
  background: var(--accent); color: #000; font-size: 11px; font-weight: 700;
  width: 22px; height: 22px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
}

/* Discard modal */
.discard-modal-list {
  display: flex; flex-direction: column; gap: 8px;
  max-height: 60vh; overflow-y: auto;
}
.discard-item {
  display: flex; align-items: center; gap: 10px;
  background: var(--bg); border-radius: 8px; padding: 10px;
  cursor: pointer; transition: background 0.2s;
  border-left: 3px solid transparent;
}
.discard-item.discard-p0 { border-left-color: var(--p0); background: linear-gradient(90deg, rgba(231,76,60,0.08), var(--bg) 40%); }
.discard-item.discard-p1 { border-left-color: var(--p1); background: linear-gradient(90deg, rgba(52,152,219,0.08), var(--bg) 40%); }
.discard-item:hover { background: var(--surface2); }
.discard-item-year {
  font-size: 20px; font-weight: 800; color: var(--accent); min-width: 50px; text-align: center;
}
.discard-item.discard-p0 .discard-item-year { color: var(--p0); }
.discard-item.discard-p1 .discard-item-year { color: var(--p1); }
.discard-item-info { flex: 1; min-width: 0; }
.discard-item-artist {
  font-size: 13px; font-weight: 600;
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.discard-item-title {
  font-size: 12px; color: var(--text-dim);
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.discard-item-player {
  font-size: 11px; color: var(--text-dim);
}

/* Victory overlay */
.victory-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.85);
  display: flex; align-items: center; justify-content: center;
  z-index: 250; padding: 20px;
}
.victory-overlay.hidden { display: none; }
.victory-card {
  background: var(--surface); border-radius: 20px; padding: 40px 30px;
  text-align: center; max-width: 400px; width: 100%;
  border: 2px solid var(--accent);
  box-shadow: 0 0 40px rgba(29, 185, 84, 0.3);
}
.victory-card.victory-p0 { border-color: var(--p0); box-shadow: 0 0 40px var(--p0-glow); }
.victory-card.victory-p1 { border-color: var(--p1); box-shadow: 0 0 40px var(--p1-glow); }
.victory-title {
  font-size: 28px; font-weight: 800; color: var(--accent);
  margin-bottom: 8px;
}
.victory-card.victory-p0 .victory-title { color: var(--p0); }
.victory-card.victory-p1 .victory-title { color: var(--p1); }
.victory-subtitle {
  font-size: 16px; color: var(--text-dim); margin-bottom: 24px;
}
.victory-actions { display: flex; flex-direction: column; gap: 10px; }

/* Setup modal additions */
.setup-player-inputs { display: flex; flex-direction: column; gap: 10px; margin-bottom: 16px; }
.setup-player-inputs input {
  background: var(--bg); border: 1px solid #444; border-radius: 8px;
  color: var(--text); padding: 10px; font-size: 14px; width: 100%;
}
.setup-player-inputs label {
  font-size: 13px; color: var(--text-dim); margin-bottom: 2px;
}
.setup-win-row { display: flex; align-items: center; gap: 10px; margin-bottom: 16px; }
.setup-win-row label { font-size: 13px; color: var(--text-dim); }
.setup-win-row select {
  background: var(--bg); border: 1px solid #444; border-radius: 8px;
  color: var(--text); padding: 6px 10px; font-size: 14px;
}
</style>
</head>
<body>

<!-- Toast container -->
<div id="toast" class="toast toast-hidden"></div>

<!-- HOME SCREEN -->
<div id="home" class="screen active">
  <div class="logo">Hit<span>Star</span></div>
  <div class="subtitle">Spotify Edition &mdash; Plays right in your browser</div>

  <!-- Connect prompt shown when no token -->
  <div class="connect-prompt" id="home-connect-prompt">
    <p>Connect your Spotify Premium account to play music directly in the browser.</p>
    <button class="btn" onclick="connectSpotifySDK()">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
      Connect Spotify Premium
    </button>
  </div>

  <div class="home-actions" id="home-actions">
    <button class="btn" onclick="showGameSetup()">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 00-3-3.87M16 3.13a4 4 0 010 7.75"/></svg>
      Start Game
    </button>
  </div>
  <div class="song-count" id="song-count"></div>
  <div id="session-playlist-indicator"></div>
  <div class="spotify-badge" id="home-spotify-badge">
    <svg viewBox="0 0 24 24"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
    <span id="home-badge-text">Connect Spotify to play</span>
  </div>
</div>

<!-- NOW PLAYING SCREEN -->
<div id="now-playing" class="screen">
  <!-- Pre-reveal: just shows that music is playing, no song info -->
  <div id="np-listening" class="np-card" style="text-align:center">
    <div class="np-category" id="np-category"></div>
    <div class="np-listening-icon">
      <svg width="64" height="64" viewBox="0 0 24 24" fill="var(--accent)" opacity="0.8"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
    </div>
    <div id="np-status-text" style="font-size:18px;font-weight:600;margin:16px 0 6px">Now playing</div>
    <div id="np-status-sub" style="font-size:14px;color:var(--text-dim)">Listen and guess the song!</div>
    <!-- SDK player controls (pre-reveal) -->
    <div class="sdk-player-controls" id="np-controls-listening">
      <button class="sdk-play-btn" id="sdk-play-btn-listening" onclick="togglePlayback()">
        <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
      </button>
      <div class="sdk-progress-wrap" id="sdk-progress-wrap-listening" onclick="seekPlayback(event, this)">
        <div class="sdk-progress-bar" id="sdk-progress-bar-listening"></div>
      </div>
    </div>
    <div class="sdk-player-error" id="sdk-error-listening"></div>
  </div>

  <!-- Post-reveal: shows full song info -->
  <div id="np-revealed" class="np-card" style="display:none">
    <div class="np-category" id="np-category-rev"></div>
    <div class="np-artist" id="np-artist"></div>
    <div class="np-title" id="np-title"></div>
    <div class="np-year" id="np-year"></div>
    <!-- SDK player controls (post-reveal) -->
    <div class="sdk-player-controls" id="np-controls-revealed">
      <button class="sdk-play-btn" id="sdk-play-btn-revealed" onclick="togglePlayback()">
        <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
      </button>
      <div class="sdk-progress-wrap" id="sdk-progress-wrap-revealed" onclick="seekPlayback(event, this)">
        <div class="sdk-progress-bar" id="sdk-progress-bar-revealed"></div>
      </div>
    </div>
    <div class="sdk-player-error" id="sdk-error-revealed"></div>
  </div>

  <div class="np-actions">
    <button class="btn btn-block" id="btn-reveal" onclick="revealSong()" style="font-size:20px;padding:18px">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
      Reveal Answer
    </button>
    <button class="btn btn-outline btn-block btn-sm" id="btn-reopen-spotify" onclick="openCurrentInSpotify()" style="display:none">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
      Open in Spotify
    </button>
    <button class="btn btn-outline btn-block" onclick="playRandom()">Next Song</button>
    <button class="btn btn-outline btn-block btn-sm" onclick="showScreen('home')" style="border-color:#555;color:#999">Back to Home</button>
  </div>
</div>

<!-- SONGS SCREEN -->
<div id="songs" class="screen">
  <div class="songs-header">
    <h1>Song Library</h1>
    <button class="btn btn-sm" onclick="showAddSongModal()">+ Add</button>
  </div>
  <div class="category-filters" id="category-filters"></div>
  <div class="song-list" id="song-list"></div>
</div>

<!-- SETTINGS SCREEN -->
<div id="settings" class="screen">
  <h1>Settings</h1>

  <div class="setting-group">
    <h3>Spotify Connection</h3>
    <p style="font-size:13px;color:var(--text-dim);margin-bottom:10px">
      Connect to Spotify Premium to play music directly in the browser via the Web Playback SDK.
    </p>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <button class="btn btn-sm" onclick="connectSpotifySDK()" id="btn-connect-sdk">Connect Spotify</button>
      <span id="sdk-connection-status" style="font-size:13px;color:var(--text-dim)"></span>
    </div>
  </div>

  <div class="setting-group">
    <h3>Import / Export Songs</h3>
    <p style="font-size:13px;color:var(--text-dim);margin-bottom:10px">
      Import a JSON song database or export your current one.
    </p>
    <div class="import-export">
      <button class="btn btn-sm btn-outline" onclick="document.getElementById('import-file').click()">Import JSON</button>
      <input type="file" id="import-file" accept=".json" onchange="importSongs(this)">
      <button class="btn btn-sm btn-outline" onclick="exportSongs()">Export JSON</button>
    </div>
  </div>

  <div class="setting-group">
    <h3>Import from Spotify Playlist</h3>
    <p style="font-size:13px;color:var(--text-dim);margin-bottom:10px">
      Import songs directly from a Spotify playlist. Paste a playlist URL or URI.
    </p>
    <input type="text" id="playlist-url" placeholder="https://open.spotify.com/playlist/... or spotify:playlist:..." style="margin-bottom:8px">
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <button class="btn btn-sm" onclick="importFromPlaylist()">Import to Library</button>
      <button class="btn btn-sm btn-outline" onclick="usePlaylistAsSource()">Use as Game Source</button>
    </div>
    <div style="margin-top:8px">
      <label style="font-size:13px;color:var(--text-dim)">
        <input type="checkbox" id="playlist-category-auto" checked> Use playlist name as category
      </label>
    </div>
    <input type="text" id="playlist-category-manual" placeholder="Or enter category manually..." style="margin-top:8px;display:none">
    <div id="playlist-status" style="font-size:13px;color:var(--text-dim);margin-top:8px"></div>
    <div style="font-size:12px;color:var(--text-dim);margin-top:10px;border-top:1px solid #333;padding-top:10px">
      <strong>Original Hitster playlists:</strong><br>
      <a href="https://open.spotify.com/user/ta8hnikdhdctwuvkj2nl9itix/playlists" target="_blank" style="color:var(--accent)">open.spotify.com/user/ta8hnikdhdctwuvkj2nl9itix/playlists</a>
    </div>
  </div>

  <div class="setting-group">
    <h3>Import from CSV / Text</h3>
    <p style="font-size:13px;color:var(--text-dim);margin-bottom:10px">
      Paste lines in the format: <code>Category\Artist - Title|Year|SpotifyID</code><br>
      Year and SpotifyID are optional. SpotifyID is the Spotify track ID (the part after <code>track/</code> in a Spotify URL).
    </p>
    <textarea id="csv-input" placeholder="Summer\SNAP! - The Power|1990|1pFMpMlSTEHN2MwBgJwkr8&#10;Rock\Queen - Bohemian Rhapsody|1975|7tFiyTwD0nx5a1eklYtX2J&#10;Basis\Alicia Keys - No One|2007"></textarea>
    <button class="btn btn-sm" style="margin-top:8px" onclick="importFromText()">Import Lines</button>
  </div>

  <div class="setting-group">
    <h3>Spotify Track Lookup</h3>
    <p style="font-size:13px;color:var(--text-dim);margin-bottom:10px">
      Songs without a Spotify Track ID cannot be played via the SDK.
      Use this to automatically look up track IDs for all songs missing them.
    </p>
    <button class="btn btn-sm btn-outline" onclick="spotifyLookupAll()">Look Up Missing Track IDs</button>
    <div id="lookup-status" style="font-size:13px;color:var(--text-dim);margin-top:8px"></div>
  </div>

  <div class="setting-group">
    <h3>Game Settings</h3>
    <div class="setting-row">
      <label>Active categories for Random mode</label>
      <div class="category-filters" id="settings-categories"></div>
    </div>
  </div>

  <div class="setting-group">
    <h3>About</h3>
    <p style="font-size:13px;color:var(--text-dim)">
      HitStar Spotify Edition<br>
      A zero-download companion for the HitStar music quiz game.<br>
      Songs play right here via Spotify Web Playback SDK &mdash; Premium account required.<br><br>
      Built as part of the <a href="https://github.com/Born2Root/HitStar" target="_blank" style="color:var(--accent)">HitStar</a> open source project.
    </p>
  </div>
</div>

<!-- ADD/EDIT SONG MODAL -->
<div class="modal-overlay hidden" id="song-modal">
  <div class="modal">
    <h2 id="modal-title">Add Song</h2>
    <div class="form-group">
      <label>Artist *</label>
      <input type="text" id="song-artist" placeholder="e.g. Queen">
    </div>
    <div class="form-group">
      <label>Title *</label>
      <input type="text" id="song-title" placeholder="e.g. Bohemian Rhapsody">
    </div>
    <div class="form-group">
      <label>Year *</label>
      <input type="number" id="song-year" placeholder="e.g. 1975" min="1900" max="2030">
    </div>
    <div class="form-group">
      <label>Category</label>
      <input type="text" id="song-category" placeholder="e.g. Rock, Summer, Basis" list="categories-datalist">
      <datalist id="categories-datalist"></datalist>
    </div>
    <div class="form-group">
      <label>Spotify Track ID (optional)</label>
      <input type="text" id="song-spotify" placeholder="e.g. 7tFiyTwD0nx5a1eklYtX2J">
      <div style="font-size:11px;color:var(--text-dim);margin-top:4px">
        Find this in Spotify: Share &rarr; Copy Link &rarr; the ID is after /track/
      </div>
    </div>
    <div class="modal-actions">
      <button class="btn btn-outline" onclick="closeSongModal()">Cancel</button>
      <button class="btn" id="modal-save-btn" onclick="saveSong()">Add Song</button>
    </div>
  </div>
</div>

<!-- GAME SETUP MODAL -->
<div class="modal-overlay hidden" id="game-setup-modal">
  <div class="modal">
    <h2>New Game</h2>
    <div class="setup-player-inputs">
      <div>
        <label style="color:#f1948a">&#9679; Player 1 (Red)</label>
        <input type="text" id="setup-p1-name" placeholder="Player 1" style="border-color:rgba(231,76,60,0.4)">
      </div>
      <div>
        <label style="color:#85c1e9">&#9679; Player 2 (Blue)</label>
        <input type="text" id="setup-p2-name" placeholder="Player 2" style="border-color:rgba(52,152,219,0.4)">
      </div>
    </div>
    <div class="setup-win-row">
      <label>Cards to win:</label>
      <select id="setup-win-count">
        <option value="5">5</option>
        <option value="7">7</option>
        <option value="10" selected>10</option>
        <option value="15">15</option>
      </select>
    </div>
    <div class="modal-actions">
      <button class="btn btn-outline" onclick="closeGameSetup()">Cancel</button>
      <button class="btn" onclick="startGame()">Start Game</button>
    </div>
  </div>
</div>

<!-- GAME BOARD SCREEN -->
<div id="game-board" class="screen">
  <!-- Top bar -->
  <div class="game-topbar">
    <button class="sdk-play-btn" id="game-play-btn" onclick="togglePlayback()">
      <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
    </button>
    <div class="sdk-progress-wrap" onclick="seekPlayback(event, this)">
      <div class="sdk-progress-bar" id="game-progress-bar"></div>
    </div>
    <div class="game-topbar-nowplaying obfuscated" id="game-nowplaying">
      <div class="game-topbar-nowplaying-year" id="game-nowplaying-year"></div>
      <div class="game-topbar-nowplaying-text">
        <div class="game-topbar-nowplaying-artist" id="game-nowplaying-artist"></div>
        <div class="game-topbar-nowplaying-title" id="game-nowplaying-title"></div>
      </div>
    </div>
    <span class="game-topbar-status" id="game-status-text"></span>
    <button class="game-topbar-btn" onclick="quitGame()">Quit</button>
  </div>
  <!-- Player rows -->
  <div class="game-body" id="game-body"></div>
</div>

<!-- DISCARD PILE MODAL -->
<div class="modal-overlay hidden" id="discard-modal">
  <div class="modal" style="max-width:480px">
    <h2>Discard Pile</h2>
    <div class="discard-modal-list" id="discard-list"></div>
    <div class="modal-actions" style="margin-top:14px">
      <button class="btn btn-outline btn-block" onclick="closeDiscardModal()">Close</button>
    </div>
  </div>
</div>

<!-- VICTORY OVERLAY -->
<div class="victory-overlay hidden" id="victory-overlay">
  <div class="victory-card">
    <div class="victory-title" id="victory-title">Player Wins!</div>
    <div class="victory-subtitle" id="victory-subtitle">With 10 cards</div>
    <div class="victory-actions">
      <button class="btn" onclick="showGameSetup()">Play Again</button>
      <button class="btn btn-outline" onclick="quitGame()">Back to Home</button>
    </div>
  </div>
</div>

<!-- NAVIGATION -->
<nav class="nav">
  <button onclick="showScreen('home')" id="nav-home" class="active">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-4 0a1 1 0 01-1-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 01-1 1"/></svg>
    Home
  </button>
  <button onclick="showScreen('songs')" id="nav-songs">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18V5l12-2v13M9 18c0 1.657-1.343 3-3 3s-3-1.343-3-3 1.343-3 3-3 3 1.343 3 3zM21 16c0 1.657-1.343 3-3 3s-3-1.343-3-3 1.343-3 3-3 3 1.343 3 3z"/></svg>
    Songs
  </button>
  <button onclick="showScreen('settings')" id="nav-settings">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 01-2.83 2.83l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-4 0v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83-2.83l.06-.06A1.65 1.65 0 004.68 15a1.65 1.65 0 00-1.51-1H3a2 2 0 010-4h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06A1.65 1.65 0 009 4.68a1.65 1.65 0 001-1.51V3a2 2 0 014 0v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06A1.65 1.65 0 0019.4 9a1.65 1.65 0 001.51 1H21a2 2 0 010 4h-.09a1.65 1.65 0 00-1.51 1z"/></svg>
    Settings
  </button>
</nav>

<!-- Spotify Web Playback SDK -->
<script src="https://sdk.scdn.co/spotify-player.js"></script>

<script>
// ==================== STATE ====================
var songs = [];
var currentSong = null;
var editingIndex = -1;
var activeCategoryFilter = 'all';
var SPOTIFY_CLIENT_ID = '487c104a2e1745778856e769dec3c079';
var gameSettings = { autoReveal: 'no', activeCategories: [], spotifyClientId: SPOTIFY_CLIENT_ID };
var spotifyToken = null;
var pendingAction = null;

// SDK playback state
var sdkPlayer = null;
var sdkDeviceId = null;
var sdkReady = false;
var sdkToken = null;
var sdkTokenExpiry = 0;
var sdkIsPlaying = false;
var sdkProgressInterval = null;
var sdkCurrentPosition = 0;
var sdkDuration = 0;

// Session playlist state
var sessionPlaylist = null;

var STORAGE_KEY = 'hitstar_songs';
var SETTINGS_KEY = 'hitstar_settings';
var PENDING_KEY = 'hitstar_pending_action';
var SDK_TOKEN_KEY = 'hitstar_sdk_token';
var SDK_TOKEN_EXPIRY_KEY = 'hitstar_sdk_token_expiry';

// SVG icon markup for play/pause buttons
var PLAY_SVG = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
var PAUSE_SVG = '<svg viewBox="0 0 24 24"><path d="M6 4h4v16H6zM14 4h4v16h-4z"/></svg>';

// ==================== TOAST NOTIFICATIONS ====================
var toastTimeout = null;
function showToast(msg, type, duration) {
  type = type || 'error';
  duration = duration || 4000;
  var el = document.getElementById('toast');
  el.textContent = msg;
  el.className = 'toast toast-' + type;
  clearTimeout(toastTimeout);
  toastTimeout = setTimeout(function() {
    el.classList.add('toast-hidden');
  }, duration);
}

// ==================== SPOTIFY WEB PLAYBACK SDK ====================
window.onSpotifyWebPlaybackSDKReady = function() {
  if (sdkToken && Date.now() < sdkTokenExpiry) {
    initializeSDKPlayer(sdkToken);
  }
};

function initializeSDKPlayer(token) {
  if (sdkPlayer) {
    sdkPlayer.disconnect();
  }

  sdkPlayer = new Spotify.Player({
    name: 'HitStar Player',
    getOAuthToken: function(cb) { cb(token); },
    volume: 0.8
  });

  sdkPlayer.addListener('initialization_error', function(e) {
    showToast('Player init failed: ' + e.message, 'error');
    updateSDKStatus('Init error');
  });
  sdkPlayer.addListener('authentication_error', function(e) {
    showToast('Spotify auth failed. Please reconnect.', 'error');
    sdkReady = false;
    sdkDeviceId = null;
    updateSDKStatus('Auth error');
    updateHomeConnectUI();
  });
  sdkPlayer.addListener('account_error', function(e) {
    showToast('Spotify account error: ' + (e.message || 'check your subscription'), 'error');
    updateSDKStatus('Account error');
  });
  sdkPlayer.addListener('playback_error', function(e) {
    showToast('Playback error: ' + e.message, 'error');
    showPlayerError('Playback error - try another track');
  });

  sdkPlayer.addListener('ready', function(data) {
    sdkDeviceId = data.device_id;
    sdkReady = true;
    updateSDKStatus('Connected');
    updateHomeConnectUI();
    showToast('Spotify connected - ready to play!', 'success', 3000);
  });

  sdkPlayer.addListener('not_ready', function(data) {
    sdkReady = false;
    sdkDeviceId = null;
    updateSDKStatus('Device offline');
    updateHomeConnectUI();
  });

  sdkPlayer.addListener('player_state_changed', function(state) {
    if (!state) {
      sdkIsPlaying = false;
      updatePlayPauseButtons();
      stopProgressTracking();
      return;
    }
    sdkIsPlaying = !state.paused;
    sdkCurrentPosition = state.position;
    sdkDuration = state.duration;
    updatePlayPauseButtons();
    updateProgressBars();
    if (sdkIsPlaying) {
      startProgressTracking();
    } else {
      stopProgressTracking();
    }
  });

  sdkPlayer.connect();
}

function updateSDKStatus(text) {
  var statusEl = document.getElementById('sdk-connection-status');
  if (statusEl) {
    statusEl.textContent = text;
    statusEl.style.color = (text === 'Connected') ? 'var(--accent)' : 'var(--text-dim)';
  }
  var btnEl = document.getElementById('btn-connect-sdk');
  if (btnEl) {
    btnEl.textContent = sdkReady ? 'Reconnect' : 'Connect Spotify';
  }
  var badgeEl = document.getElementById('home-badge-text');
  if (badgeEl) {
    badgeEl.textContent = sdkReady ? 'Connected - plays in browser' : 'Connect Spotify to play';
  }
}

function updateHomeConnectUI() {
  var prompt = document.getElementById('home-connect-prompt');
  if (!prompt) return;
  prompt.style.display = sdkReady ? 'none' : '';
}

function connectSpotifySDK() {
  gameSettings.spotifyClientId = SPOTIFY_CLIENT_ID;
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(gameSettings));
  requireSpotifyAuth('sdk');
}

// ==================== PLAY/PAUSE CONTROLS ====================
function updatePlayPauseButtons() {
  var btn1 = document.getElementById('sdk-play-btn-listening');
  var btn2 = document.getElementById('sdk-play-btn-revealed');
  if (sdkIsPlaying) {
    if (btn1) btn1.innerHTML = PAUSE_SVG;
    if (btn2) btn2.innerHTML = PAUSE_SVG;
  } else {
    if (btn1) btn1.innerHTML = PLAY_SVG;
    if (btn2) btn2.innerHTML = PLAY_SVG;
  }
}

function togglePlayback() {
  if (!sdkPlayer || !sdkReady) {
    showToast('Spotify not connected. Go to Settings to connect.', 'error');
    return;
  }
  sdkPlayer.togglePlay();
}

function seekPlayback(event, wrapEl) {
  if (!sdkPlayer || !sdkReady || sdkDuration === 0) return;
  var rect = wrapEl.getBoundingClientRect();
  var x = event.clientX - rect.left;
  var pct = Math.max(0, Math.min(1, x / rect.width));
  var posMs = Math.floor(pct * sdkDuration);
  sdkPlayer.seek(posMs);
}

// ==================== PROGRESS TRACKING ====================
function startProgressTracking() {
  stopProgressTracking();
  sdkProgressInterval = setInterval(function() {
    if (sdkIsPlaying && sdkDuration > 0) {
      sdkCurrentPosition += 300;
      if (sdkCurrentPosition > sdkDuration) sdkCurrentPosition = sdkDuration;
      updateProgressBars();
    }
  }, 300);
}

function stopProgressTracking() {
  if (sdkProgressInterval) {
    clearInterval(sdkProgressInterval);
    sdkProgressInterval = null;
  }
}

function updateProgressBars() {
  var pct = sdkDuration > 0 ? (sdkCurrentPosition / sdkDuration * 100) : 0;
  var bar1 = document.getElementById('sdk-progress-bar-listening');
  var bar2 = document.getElementById('sdk-progress-bar-revealed');
  if (bar1) bar1.style.width = pct + '%';
  if (bar2) bar2.style.width = pct + '%';
}

function resetProgressBars() {
  sdkCurrentPosition = 0;
  sdkDuration = 0;
  sdkIsPlaying = false;
  updateProgressBars();
  updatePlayPauseButtons();
  stopProgressTracking();
}

function showPlayerError(msg) {
  var e1 = document.getElementById('sdk-error-listening');
  var e2 = document.getElementById('sdk-error-revealed');
  if (e1) e1.textContent = msg;
  if (e2) e2.textContent = msg;
}

function clearPlayerError() {
  showPlayerError('');
}

// ==================== INIT ====================
function init() {
  loadSongs();
  loadSettings();
  updateSongCount();
  renderSongList();
  renderCategoryFilters();

  // Restore SDK token from storage if still valid
  var storedToken = localStorage.getItem(SDK_TOKEN_KEY);
  var storedExpiry = parseInt(localStorage.getItem(SDK_TOKEN_EXPIRY_KEY) || '0');
  if (storedToken && Date.now() < storedExpiry) {
    sdkToken = storedToken;
    sdkTokenExpiry = storedExpiry;
    if (window.Spotify && window.Spotify.Player) {
      initializeSDKPlayer(sdkToken);
    }
  }

  // Check for Spotify OAuth PKCE callback (?code=...)
  var urlParams = new URLSearchParams(window.location.search);
  var authCode = urlParams.get('code');
  if (authCode) {
    history.replaceState(null, '', window.location.pathname);
    pendingAction = localStorage.getItem(PENDING_KEY) || 'sdk';
    localStorage.removeItem(PENDING_KEY);
    handleAuthCode(authCode, pendingAction);
  }

  // Also handle legacy implicit grant callback (#access_token=...) for backwards compat
  var hash = window.location.hash;
  if (hash.includes('access_token')) {
    var hparams = new URLSearchParams(hash.substring(1));
    var htoken = hparams.get('access_token');
    var hexpiresIn = parseInt(hparams.get('expires_in') || '3600');
    window.location.hash = '';
    history.replaceState(null, '', window.location.pathname);
    pendingAction = localStorage.getItem(PENDING_KEY) || 'sdk';
    localStorage.removeItem(PENDING_KEY);
    applyToken(htoken, hexpiresIn, pendingAction);
  }

  // Toggle manual category input visibility
  var autoCheck = document.getElementById('playlist-category-auto');
  if (autoCheck) {
    autoCheck.addEventListener('change', function() {
      document.getElementById('playlist-category-manual').style.display = autoCheck.checked ? 'none' : 'block';
    });
  }

  // Load example songs if empty
  if (songs.length === 0) {
    loadExampleSongs();
  }

  // Ensure hardcoded client ID is always set
  gameSettings.spotifyClientId = SPOTIFY_CLIENT_ID;

  updateHomeConnectUI();
  updateSessionPlaylistIndicator();
}

// Exchange PKCE auth code for token, then apply it
async function handleAuthCode(code, action) {
  showToast('Connecting to Spotify...', 'success', 10000);
  var data = await exchangeCodeForToken(code);
  if (!data || !data.access_token) {
    showToast('Failed to connect to Spotify. Please try again.', 'error');
    return;
  }
  applyToken(data.access_token, data.expires_in || 3600, action);
}

// Store token and initialize SDK + trigger pending action
function applyToken(token, expiresIn, action) {
  sdkToken = token;
  sdkTokenExpiry = Date.now() + expiresIn * 1000;
  localStorage.setItem(SDK_TOKEN_KEY, sdkToken);
  localStorage.setItem(SDK_TOKEN_EXPIRY_KEY, String(sdkTokenExpiry));

  if (window.Spotify && window.Spotify.Player && !sdkReady) {
    initializeSDKPlayer(sdkToken);
  }

  if (action === 'playlist' || action === 'playlist-source') {
    spotifyToken = token;
    if (action === 'playlist-source') {
      importPlaylistAsSource();
    } else {
      importPlaylistWithToken();
    }
  } else if (action === 'lookup') {
    spotifyToken = token;
    spotifyLookupWithToken();
  }
}

// ==================== SONGS DATA ====================
function loadSongs() {
  try {
    var stored = localStorage.getItem(STORAGE_KEY);
    if (stored) songs = JSON.parse(stored);
  } catch (e) { songs = []; }
}

function saveSongsToStorage() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(songs));
  updateSongCount();
}

function loadSettings() {
  try {
    var stored = localStorage.getItem(SETTINGS_KEY);
    if (stored) {
      var parsed = JSON.parse(stored);
      for (var k in parsed) {
        if (parsed.hasOwnProperty(k)) gameSettings[k] = parsed[k];
      }
    }
  } catch (e) {}
  // Always use hardcoded client ID
  gameSettings.spotifyClientId = SPOTIFY_CLIENT_ID;
}

function saveSetting(key, value) {
  gameSettings[key] = value;
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(gameSettings));
}

function updateSongCount() {
  var cats = getCategories();
  var catStr = cats.length > 0 ? ' in ' + cats.length + ' categories' : '';
  var source = sessionPlaylist ? ' (Session: ' + sessionPlaylist.name + ')' : '';
  document.getElementById('song-count').textContent = songs.length + ' songs loaded' + catStr + source;
}

function getCategories() {
  var cats = new Set();
  songs.forEach(function(s) { if (s.category) cats.add(s.category); });
  return Array.from(cats).sort();
}

function getActiveCategories() {
  if (!gameSettings.activeCategories || gameSettings.activeCategories.length === 0) return getCategories();
  return gameSettings.activeCategories;
}

async function loadExampleSongs() {
  try {
    var resp = await fetch('songs-example.json');
    if (resp.ok) {
      var data = await resp.json();
      songs = data;
      saveSongsToStorage();
      renderSongList();
      renderCategoryFilters();
    }
  } catch (e) {}
}

// ==================== NAVIGATION ====================
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(function(s) { s.classList.remove('active'); });
  document.getElementById(id).classList.add('active');
  document.querySelectorAll('.nav button').forEach(function(b) { b.classList.remove('active'); });
  var navBtn = document.getElementById('nav-' + id);
  if (navBtn) navBtn.classList.add('active');

  if (id === 'songs') { renderSongList(); renderCategoryFilters(); }
  if (id === 'settings') renderSettingsCategories();
}

// ==================== PLAYBACK ====================

async function playSong(song) {
  currentSong = song;
  clearPlayerError();
  resetProgressBars();

  document.getElementById('np-category').textContent = song.category || 'Unknown';
  document.getElementById('np-category-rev').textContent = song.category || 'Unknown';
  document.getElementById('np-artist').textContent = song.artist;
  document.getElementById('np-title').textContent = song.title;
  document.getElementById('np-year').textContent = song.year || '????';

  document.getElementById('np-listening').style.display = '';
  document.getElementById('np-revealed').style.display = 'none';
  document.getElementById('btn-reveal').style.display = '';
  document.getElementById('btn-reopen-spotify').style.display = 'none';

  showScreen('now-playing');

  if (sdkReady && sdkDeviceId) {
    // Will auto-resolve spotifyId via Search API if missing
    var success = await startSDKPlayback(song);
    if (success) {
      document.getElementById('np-status-text').textContent = 'Now playing';
      document.getElementById('np-status-sub').textContent = 'Listen and guess the song!';
      return;
    }
  }

  if (!sdkReady) {
    document.getElementById('np-status-text').textContent = 'Spotify not connected';
    document.getElementById('np-status-sub').textContent = 'Go to Settings to connect your Spotify account';
    showPlayerError('Connect Spotify in Settings to enable playback');
  } else if (!song.spotifyId) {
    document.getElementById('np-status-text').textContent = 'Track not found';
    document.getElementById('np-status-sub').textContent = 'Could not find this song on Spotify';
    showPlayerError('Song not found on Spotify');
  } else {
    document.getElementById('np-status-text').textContent = 'Playback failed';
    document.getElementById('np-status-sub').textContent = 'Could not start playback for this track';
    showPlayerError('Playback failed - try another track');
  }
}

// Look up a Spotify track ID via the Search API.
// Caches the result on the song object and in localStorage.
async function searchSpotifyId(song) {
  if (!sdkToken || !song.artist || !song.title) return null;
  try {
    var q = encodeURIComponent('track:' + song.title + ' artist:' + song.artist);
    var resp = await fetch('https://api.spotify.com/v1/search?q=' + q + '&type=track&limit=1', {
      headers: { 'Authorization': 'Bearer ' + sdkToken }
    });
    if (!resp.ok) return null;
    var data = await resp.json();
    var tracks = data.tracks && data.tracks.items;
    if (tracks && tracks.length > 0) {
      var track = tracks[0];
      var newId = track.id;
      song.spotifyId = newId;
      // Grab album art (prefer 300px, fall back to largest)
      if (track.album && track.album.images && track.album.images.length > 0) {
        song.albumArt = (track.album.images[1] || track.album.images[0]).url;
      }
      var idx = songs.indexOf(song);
      if (idx >= 0) {
        songs[idx].spotifyId = newId;
        localStorage.setItem(STORAGE_KEY, JSON.stringify(songs));
      }
      return newId;
    }
  } catch (e) { /* ignore */ }
  return null;
}

async function playTrackById(trackId) {
  var resp = await fetch('https://api.spotify.com/v1/me/player/play?device_id=' + sdkDeviceId, {
    method: 'PUT',
    headers: {
      'Authorization': 'Bearer ' + sdkToken,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ uris: ['spotify:track:' + trackId] })
  });
  return resp;
}

async function startSDKPlayback(song) {
  if (!sdkReady || !sdkDeviceId || !sdkToken) return false;

  // Always verify the track ID via search to catch wrong-song mappings.
  // searchSpotifyId updates song.spotifyId and caches the result.
  if (song.artist && song.title) {
    await searchSpotifyId(song);
  }

  if (!song.spotifyId) return false;

  try {
    var resp = await playTrackById(song.spotifyId);

    if (resp.status === 204 || resp.status === 200) return true;

    if (resp.status === 401) {
      sdkToken = null;
      sdkTokenExpiry = 0;
      localStorage.removeItem(SDK_TOKEN_KEY);
      localStorage.removeItem(SDK_TOKEN_EXPIRY_KEY);
      sdkReady = false;
      if (sdkPlayer) sdkPlayer.disconnect();
      updateSDKStatus('Session expired');
      updateHomeConnectUI();
      showToast('Spotify session expired. Please reconnect.', 'error');
      return false;
    }

    if (resp.status === 403 || resp.status === 404) {
      showToast('Track not available on Spotify', 'error');
      return false;
    }

    return false;
  } catch (e) {
    return false;
  }
}

function getSpotifyUrl(song) {
  if (song.spotifyId) {
    return 'https://open.spotify.com/track/' + song.spotifyId;
  }
  var query = encodeURIComponent(song.artist + ' ' + song.title);
  return 'https://open.spotify.com/search/' + query;
}

function openCurrentInSpotify() {
  if (!currentSong) return;
  window.open(getSpotifyUrl(currentSong), '_blank');
}

function revealSong() {
  document.getElementById('np-listening').style.display = 'none';
  document.getElementById('np-revealed').style.display = '';
  document.getElementById('btn-reveal').style.display = 'none';
  document.getElementById('btn-reopen-spotify').style.display = '';
}

function playRandom() {
  var pool;
  if (sessionPlaylist && sessionPlaylist.tracks.length > 0) {
    pool = sessionPlaylist.tracks;
  } else {
    if (songs.length === 0) {
      alert('No songs loaded! Add songs in the Songs tab or import a song database in Settings.');
      return;
    }
    var activeCats = getActiveCategories();
    pool = activeCats.length > 0
      ? songs.filter(function(s) { return activeCats.includes(s.category); })
      : songs;
  }

  if (pool.length === 0) {
    alert('No songs in the selected categories.');
    return;
  }

  var idx = Math.floor(Math.random() * pool.length);
  playSong(pool[idx]);
}

// ==================== SESSION PLAYLIST ====================
function usePlaylistAsSource() {
  var urlInput = document.getElementById('playlist-url').value.trim();
  if (!urlInput) { alert('Please paste a Spotify playlist URL or URI.'); return; }

  var playlistId = null;
  var urlMatch = urlInput.match(/playlist[/:]([a-zA-Z0-9]+)/);
  if (urlMatch) playlistId = urlMatch[1];
  if (!playlistId) { alert('Could not find a playlist ID in that URL.'); return; }

  localStorage.setItem('hitstar_pending_playlist', playlistId);
  var autoCategory = document.getElementById('playlist-category-auto').checked;
  var manualCategory = document.getElementById('playlist-category-manual').value.trim();
  localStorage.setItem('hitstar_pending_playlist_category', autoCategory ? '__auto__' : manualCategory);

  requireSpotifyAuth('playlist-source');
}

async function importPlaylistAsSource() {
  if (!spotifyToken) return;

  var playlistId = localStorage.getItem('hitstar_pending_playlist');
  var categoryPref = localStorage.getItem('hitstar_pending_playlist_category') || '__auto__';
  localStorage.removeItem('hitstar_pending_playlist');
  localStorage.removeItem('hitstar_pending_playlist_category');

  if (!playlistId) { alert('No playlist ID found. Please try again.'); return; }

  var statusEl = document.getElementById('playlist-status');
  statusEl.textContent = 'Fetching playlist for game source...';
  showScreen('settings');

  try {
    var plResp = await fetch('https://api.spotify.com/v1/playlists/' + playlistId + '?fields=name,tracks.total', {
      headers: { 'Authorization': 'Bearer ' + spotifyToken }
    });
    if (!plResp.ok) { statusEl.textContent = 'Error fetching playlist: ' + plResp.status; return; }
    var plData = await plResp.json();
    var category = categoryPref === '__auto__' ? plData.name : (categoryPref || plData.name);
    var totalTracks = plData.tracks.total;
    statusEl.textContent = 'Loading "' + plData.name + '" as game source (' + totalTracks + ' tracks)...';

    var tracks = [];
    var offset = 0;
    var limit = 100;

    while (offset < totalTracks) {
      var tracksResp = await fetch(
        'https://api.spotify.com/v1/playlists/' + playlistId + '/tracks?offset=' + offset + '&limit=' + limit + '&fields=items(track(id,name,artists(name),album(release_date)))',
        { headers: { 'Authorization': 'Bearer ' + spotifyToken } }
      );

      if (tracksResp.status === 429) {
        var retry = parseInt(tracksResp.headers.get('Retry-After') || '2');
        await new Promise(function(r) { setTimeout(r, retry * 1000); });
        continue;
      }

      if (!tracksResp.ok) { statusEl.textContent = 'Error fetching tracks: ' + tracksResp.status; break; }

      var tracksData = await tracksResp.json();
      for (var i = 0; i < tracksData.items.length; i++) {
        var item = tracksData.items[i];
        var track = item.track;
        if (!track || !track.id) continue;

        var artist = track.artists.map(function(a) { return a.name; }).join(', ');
        var title = track.name;
        var year = track.album && track.album.release_date
          ? parseInt(track.album.release_date.substring(0, 4)) || null
          : null;

        tracks.push({
          artist: artist,
          title: title,
          year: year,
          category: category,
          spotifyId: track.id,
          qrCode: category + '/' + artist + ' - ' + title
        });
      }

      offset += limit;
      statusEl.textContent = 'Loading "' + plData.name + '"... ' + tracks.length + '/' + totalTracks;
      await new Promise(function(r) { setTimeout(r, 50); });
    }

    sessionPlaylist = { name: plData.name, tracks: tracks };
    updateSessionPlaylistIndicator();
    updateSongCount();
    statusEl.textContent = 'Game source set to "' + plData.name + '" (' + tracks.length + ' tracks). Random Song will pick from this playlist.';
    showToast('Session playlist active: ' + plData.name, 'success', 3000);
  } catch (e) {
    statusEl.textContent = 'Error: ' + e.message;
  }
  spotifyToken = null;
}

function clearSessionPlaylist() {
  sessionPlaylist = null;
  updateSessionPlaylistIndicator();
  updateSongCount();
  showToast('Session playlist cleared. Using song library.', 'success', 3000);
}

function updateSessionPlaylistIndicator() {
  var container = document.getElementById('session-playlist-indicator');
  if (!container) return;
  if (sessionPlaylist) {
    // Build indicator using DOM methods to avoid innerHTML with dynamic content
    container.textContent = '';
    var badge = document.createElement('div');
    badge.className = 'session-playlist-badge';
    var label = document.createTextNode('Session: ' + sessionPlaylist.name + ' (' + sessionPlaylist.tracks.length + ' tracks)');
    badge.appendChild(label);
    var closeBtn = document.createElement('button');
    closeBtn.setAttribute('onclick', 'clearSessionPlaylist()');
    closeBtn.setAttribute('title', 'Clear session playlist');
    closeBtn.textContent = '\u2715';
    badge.appendChild(closeBtn);
    container.appendChild(badge);
  } else {
    container.textContent = '';
  }
}

// ==================== SONG LIST UI ====================
function renderCategoryFilters() {
  var cats = getCategories();
  var container = document.getElementById('category-filters');
  container.textContent = '';

  var allChip = document.createElement('span');
  allChip.className = 'cat-chip' + (activeCategoryFilter === 'all' ? ' active' : '');
  allChip.textContent = 'All (' + songs.length + ')';
  allChip.onclick = function() { activeCategoryFilter = 'all'; renderCategoryFilters(); renderSongList(); };
  container.appendChild(allChip);

  cats.forEach(function(cat) {
    var count = songs.filter(function(s) { return s.category === cat; }).length;
    var chip = document.createElement('span');
    chip.className = 'cat-chip' + (activeCategoryFilter === cat ? ' active' : '');
    chip.textContent = cat + ' (' + count + ')';
    chip.onclick = function() { activeCategoryFilter = cat; renderCategoryFilters(); renderSongList(); };
    container.appendChild(chip);
  });

  var dl = document.getElementById('categories-datalist');
  dl.textContent = '';
  cats.forEach(function(c) { var o = document.createElement('option'); o.value = c; dl.appendChild(o); });
}

function renderSettingsCategories() {
  var cats = getCategories();
  var container = document.getElementById('settings-categories');
  container.textContent = '';
  var active = gameSettings.activeCategories || [];

  cats.forEach(function(cat) {
    var chip = document.createElement('span');
    chip.className = 'cat-chip' + (active.length === 0 || active.includes(cat) ? ' active' : '');
    chip.textContent = cat;
    chip.onclick = function() {
      if (active.length === 0) {
        gameSettings.activeCategories = [cat];
      } else if (active.includes(cat)) {
        gameSettings.activeCategories = active.filter(function(c) { return c !== cat; });
        if (gameSettings.activeCategories.length === 0) gameSettings.activeCategories = [];
      } else {
        gameSettings.activeCategories.push(cat);
      }
      saveSetting('activeCategories', gameSettings.activeCategories);
      renderSettingsCategories();
    };
    container.appendChild(chip);
  });
}

function renderSongList() {
  var container = document.getElementById('song-list');
  var filtered = activeCategoryFilter === 'all' ? songs : songs.filter(function(s) { return s.category === activeCategoryFilter; });

  if (filtered.length === 0) {
    container.textContent = '';
    var empty = document.createElement('div');
    empty.className = 'song-empty';
    empty.textContent = songs.length === 0 ? 'No songs yet. Add songs manually or import a database in Settings.' : 'No songs in this category.';
    container.appendChild(empty);
    return;
  }

  filtered.sort(function(a, b) { return (a.year || 0) - (b.year || 0); });

  // Build song list using DOM methods
  container.textContent = '';
  filtered.forEach(function(s) {
    var realIdx = songs.indexOf(s);

    var item = document.createElement('div');
    item.className = 'song-item';

    var info = document.createElement('div');
    info.className = 'song-item-info';

    var artistDiv = document.createElement('div');
    artistDiv.className = 'artist';
    artistDiv.textContent = s.artist;
    info.appendChild(artistDiv);

    var titleDiv = document.createElement('div');
    titleDiv.className = 'title';
    titleDiv.textContent = s.title;
    info.appendChild(titleDiv);

    var metaDiv = document.createElement('div');
    metaDiv.className = 'meta';
    var spotifyDot = document.createElement('span');
    spotifyDot.style.color = s.spotifyId ? 'var(--accent)' : '#666';
    spotifyDot.textContent = s.spotifyId ? '\u25CF' : '\u25CB';
    metaDiv.appendChild(document.createTextNode((s.year || '?') + ' \u00B7 ' + (s.category || '?') + ' \u00B7 '));
    metaDiv.appendChild(spotifyDot);
    metaDiv.appendChild(document.createTextNode(' Spotify'));
    info.appendChild(metaDiv);

    item.appendChild(info);

    var actions = document.createElement('div');
    actions.className = 'song-item-actions';

    var playBtn = document.createElement('button');
    playBtn.className = 'icon-btn';
    playBtn.title = 'Play';
    playBtn.textContent = '\u25B6';
    playBtn.setAttribute('data-idx', realIdx);
    playBtn.onclick = function() { playSong(songs[parseInt(this.getAttribute('data-idx'))]); };
    actions.appendChild(playBtn);

    var editBtn = document.createElement('button');
    editBtn.className = 'icon-btn';
    editBtn.title = 'Edit';
    editBtn.textContent = '\u270E';
    editBtn.setAttribute('data-idx', realIdx);
    editBtn.onclick = function() { showEditSongModal(parseInt(this.getAttribute('data-idx'))); };
    actions.appendChild(editBtn);

    var delBtn = document.createElement('button');
    delBtn.className = 'icon-btn';
    delBtn.title = 'Delete';
    delBtn.style.color = 'var(--danger)';
    delBtn.textContent = '\u2715';
    delBtn.setAttribute('data-idx', realIdx);
    delBtn.onclick = function() { deleteSong(parseInt(this.getAttribute('data-idx'))); };
    actions.appendChild(delBtn);

    item.appendChild(actions);
    container.appendChild(item);
  });
}

function esc(s) {
  if (!s) return '';
  var d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// ==================== SONG CRUD ====================
function showAddSongModal() {
  editingIndex = -1;
  document.getElementById('modal-title').textContent = 'Add Song';
  document.getElementById('modal-save-btn').textContent = 'Add Song';
  document.getElementById('song-artist').value = '';
  document.getElementById('song-title').value = '';
  document.getElementById('song-year').value = '';
  document.getElementById('song-category').value = '';
  document.getElementById('song-spotify').value = '';
  document.getElementById('song-modal').classList.remove('hidden');
}

function showEditSongModal(idx) {
  editingIndex = idx;
  var s = songs[idx];
  document.getElementById('modal-title').textContent = 'Edit Song';
  document.getElementById('modal-save-btn').textContent = 'Save';
  document.getElementById('song-artist').value = s.artist || '';
  document.getElementById('song-title').value = s.title || '';
  document.getElementById('song-year').value = s.year || '';
  document.getElementById('song-category').value = s.category || '';
  document.getElementById('song-spotify').value = s.spotifyId || '';
  document.getElementById('song-modal').classList.remove('hidden');
}

function closeSongModal() {
  document.getElementById('song-modal').classList.add('hidden');
}

function saveSong() {
  var artist = document.getElementById('song-artist').value.trim();
  var title = document.getElementById('song-title').value.trim();
  var year = parseInt(document.getElementById('song-year').value) || null;
  var category = document.getElementById('song-category').value.trim();
  var spotifyId = document.getElementById('song-spotify').value.trim();

  if (!artist || !title) { alert('Artist and Title are required.'); return; }

  var urlMatch = spotifyId.match(/track\/([a-zA-Z0-9]+)/);
  if (urlMatch) spotifyId = urlMatch[1];
  var uriMatch = spotifyId.match(/spotify:track:([a-zA-Z0-9]+)/);
  if (uriMatch) spotifyId = uriMatch[1];

  var qrCode = category ? category + '/' + artist + ' - ' + title : artist + ' - ' + title;

  var song = { artist: artist, title: title, year: year, category: category, spotifyId: spotifyId || null, qrCode: qrCode };

  if (editingIndex >= 0) {
    songs[editingIndex] = song;
  } else {
    songs.push(song);
  }

  saveSongsToStorage();
  closeSongModal();
  renderSongList();
  renderCategoryFilters();
}

function deleteSong(idx) {
  if (confirm('Delete "' + songs[idx].artist + ' - ' + songs[idx].title + '"?')) {
    songs.splice(idx, 1);
    saveSongsToStorage();
    renderSongList();
    renderCategoryFilters();
  }
}

// ==================== IMPORT / EXPORT ====================
function importSongs(input) {
  var file = input.files[0];
  if (!file) return;
  var reader = new FileReader();
  reader.onload = function(e) {
    try {
      var data = JSON.parse(e.target.result);
      if (Array.isArray(data)) {
        if (songs.length > 0 && !confirm('Replace ' + songs.length + ' existing songs with ' + data.length + ' imported songs?')) return;
        songs = data;
        saveSongsToStorage();
        renderSongList();
        renderCategoryFilters();
        alert('Imported ' + data.length + ' songs!');
      } else {
        alert('Invalid format: expected a JSON array.');
      }
    } catch (err) {
      alert('Error parsing JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
  input.value = '';
}

function exportSongs() {
  var blob = new Blob([JSON.stringify(songs, null, 2)], { type: 'application/json' });
  var url = URL.createObjectURL(blob);
  var a = document.createElement('a');
  a.href = url;
  a.download = 'hitstar-songs.json';
  a.click();
  URL.revokeObjectURL(url);
}

function importFromText() {
  var text = document.getElementById('csv-input').value.trim();
  if (!text) return;

  var lines = text.split('\n').filter(function(l) { return l.trim(); });
  var added = 0;

  lines.forEach(function(line) {
    line = line.trim();
    var pipes = line.split('|');
    var pathPart = pipes[0].trim();
    var year = pipes[1] ? parseInt(pipes[1].trim()) || null : null;
    var spotifyId = pipes[2] ? pipes[2].trim() : null;

    if (spotifyId) {
      var m = spotifyId.match(/track\/([a-zA-Z0-9]+)/);
      if (m) spotifyId = m[1];
    }

    var normalized = pathPart.replace(/\\/g, '/').replace(/\.(mp3|flac|ogg|wav|m4a)$/i, '');
    var slashIdx = normalized.indexOf('/');

    var category = '', artistTitle = '';
    if (slashIdx > 0) {
      category = normalized.substring(0, slashIdx).trim();
      artistTitle = normalized.substring(slashIdx + 1).trim();
    } else {
      artistTitle = normalized;
    }

    var dashIdx = artistTitle.indexOf(' - ');
    if (dashIdx > 0) {
      var artist = artistTitle.substring(0, dashIdx).trim();
      var title = artistTitle.substring(dashIdx + 3).trim();
      var qrCode = category ? category + '/' + artist + ' - ' + title : artist + ' - ' + title;

      var exists = songs.some(function(s) {
        return s.artist.toLowerCase() === artist.toLowerCase() &&
          s.title.toLowerCase() === title.toLowerCase();
      });
      if (!exists) {
        songs.push({ artist: artist, title: title, year: year, category: category, spotifyId: spotifyId, qrCode: qrCode });
        added++;
      }
    }
  });

  saveSongsToStorage();
  renderSongList();
  renderCategoryFilters();
  document.getElementById('csv-input').value = '';
  alert('Imported ' + added + ' new songs (' + (lines.length - added) + ' skipped as duplicates).');
}

// ==================== SPOTIFY AUTH (PKCE) ====================
var PKCE_VERIFIER_KEY = 'hitstar_pkce_verifier';

function generateCodeVerifier() {
  var arr = new Uint8Array(64);
  crypto.getRandomValues(arr);
  return btoa(String.fromCharCode.apply(null, arr))
    .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

async function generateCodeChallenge(verifier) {
  var encoder = new TextEncoder();
  var data = encoder.encode(verifier);
  var digest = await crypto.subtle.digest('SHA-256', data);
  return btoa(String.fromCharCode.apply(null, new Uint8Array(digest)))
    .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

async function requireSpotifyAuth(action) {
  localStorage.setItem(PENDING_KEY, action);
  var verifier = generateCodeVerifier();
  localStorage.setItem(PKCE_VERIFIER_KEY, verifier);
  var challenge = await generateCodeChallenge(verifier);
  var redirectUri = encodeURIComponent(window.location.origin + window.location.pathname);
  var scopes = 'streaming user-read-email user-read-private user-modify-playback-state user-read-playback-state playlist-read-private playlist-read-collaborative';
  var authUrl = 'https://accounts.spotify.com/authorize?client_id=' + SPOTIFY_CLIENT_ID
    + '&response_type=code&redirect_uri=' + redirectUri
    + '&scope=' + encodeURIComponent(scopes)
    + '&code_challenge_method=S256&code_challenge=' + challenge;
  window.location.href = authUrl;
  return true;
}

async function exchangeCodeForToken(code) {
  var verifier = localStorage.getItem(PKCE_VERIFIER_KEY);
  localStorage.removeItem(PKCE_VERIFIER_KEY);
  if (!verifier) return null;

  var redirectUri = window.location.origin + window.location.pathname;
  var resp = await fetch('https://accounts.spotify.com/api/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: 'grant_type=authorization_code&code=' + encodeURIComponent(code)
      + '&redirect_uri=' + encodeURIComponent(redirectUri)
      + '&client_id=' + encodeURIComponent(SPOTIFY_CLIENT_ID)
      + '&code_verifier=' + encodeURIComponent(verifier)
  });
  if (!resp.ok) return null;
  return await resp.json();
}

// ==================== SPOTIFY PLAYLIST IMPORT ====================
function importFromPlaylist() {
  var urlInput = document.getElementById('playlist-url').value.trim();
  if (!urlInput) { alert('Please paste a Spotify playlist URL or URI.'); return; }

  var playlistId = null;
  var urlMatch = urlInput.match(/playlist[/:]([a-zA-Z0-9]+)/);
  if (urlMatch) playlistId = urlMatch[1];
  if (!playlistId) { alert('Could not find a playlist ID in that URL. Expected format:\nhttps://open.spotify.com/playlist/XXXXX'); return; }

  localStorage.setItem('hitstar_pending_playlist', playlistId);
  var autoCategory = document.getElementById('playlist-category-auto').checked;
  var manualCategory = document.getElementById('playlist-category-manual').value.trim();
  localStorage.setItem('hitstar_pending_playlist_category', autoCategory ? '__auto__' : manualCategory);

  requireSpotifyAuth('playlist');
}

async function importPlaylistWithToken() {
  if (!spotifyToken) return;

  var playlistId = localStorage.getItem('hitstar_pending_playlist');
  var categoryPref = localStorage.getItem('hitstar_pending_playlist_category') || '__auto__';
  localStorage.removeItem('hitstar_pending_playlist');
  localStorage.removeItem('hitstar_pending_playlist_category');

  if (!playlistId) { alert('No playlist ID found. Please try again.'); return; }

  var statusEl = document.getElementById('playlist-status');
  statusEl.textContent = 'Fetching playlist...';
  showScreen('settings');

  try {
    var plResp = await fetch('https://api.spotify.com/v1/playlists/' + playlistId + '?fields=name,tracks.total', {
      headers: { 'Authorization': 'Bearer ' + spotifyToken }
    });
    if (!plResp.ok) { statusEl.textContent = 'Error fetching playlist: ' + plResp.status; return; }
    var plData = await plResp.json();
    var category = categoryPref === '__auto__' ? plData.name : (categoryPref || plData.name);
    var totalTracks = plData.tracks.total;
    statusEl.textContent = 'Importing "' + plData.name + '" (' + totalTracks + ' tracks)...';

    var added = 0, skipped = 0;
    var offset = 0;
    var limit = 100;

    while (offset < totalTracks) {
      var tracksResp = await fetch(
        'https://api.spotify.com/v1/playlists/' + playlistId + '/tracks?offset=' + offset + '&limit=' + limit + '&fields=items(track(id,name,artists(name),album(release_date)))',
        { headers: { 'Authorization': 'Bearer ' + spotifyToken } }
      );

      if (tracksResp.status === 429) {
        var retry = parseInt(tracksResp.headers.get('Retry-After') || '2');
        await new Promise(function(r) { setTimeout(r, retry * 1000); });
        continue;
      }

      if (!tracksResp.ok) { statusEl.textContent = 'Error fetching tracks: ' + tracksResp.status; break; }

      var tracksData = await tracksResp.json();
      for (var i = 0; i < tracksData.items.length; i++) {
        var item = tracksData.items[i];
        var track = item.track;
        if (!track || !track.id) { skipped++; continue; }

        var artist = track.artists.map(function(a) { return a.name; }).join(', ');
        var title = track.name;
        var year = track.album && track.album.release_date
          ? parseInt(track.album.release_date.substring(0, 4)) || null
          : null;

        var exists = songs.some(function(s) {
          return s.artist.toLowerCase() === artist.toLowerCase() &&
            s.title.toLowerCase() === title.toLowerCase();
        });
        if (exists) { skipped++; continue; }

        songs.push({
          artist: artist,
          title: title,
          year: year,
          category: category,
          spotifyId: track.id,
          qrCode: category + '/' + artist + ' - ' + title
        });
        added++;
      }

      offset += limit;
      statusEl.textContent = 'Importing "' + plData.name + '"... ' + added + ' added, ' + skipped + ' skipped (' + offset + '/' + totalTracks + ')';
      await new Promise(function(r) { setTimeout(r, 50); });
    }

    saveSongsToStorage();
    renderSongList();
    renderCategoryFilters();
    statusEl.textContent = 'Done! Imported ' + added + ' songs from "' + plData.name + '" (' + skipped + ' skipped as duplicates or empty).';
  } catch (e) {
    statusEl.textContent = 'Error: ' + e.message;
  }
  spotifyToken = null;
}

// ==================== SPOTIFY TRACK LOOKUP ====================
function spotifyLookupAll() {
  var missing = songs.filter(function(s) { return !s.spotifyId; });
  if (missing.length === 0) {
    alert('All songs already have Spotify Track IDs!');
    return;
  }
  requireSpotifyAuth('lookup');
}

async function spotifyLookupWithToken() {
  if (!spotifyToken) return;

  var missing = songs.filter(function(s) { return !s.spotifyId; });
  var statusEl = document.getElementById('lookup-status');
  statusEl.textContent = 'Looking up ' + missing.length + ' songs...';
  showScreen('settings');

  var found = 0;
  for (var i = 0; i < missing.length; i++) {
    var s = missing[i];
    statusEl.textContent = 'Looking up ' + (i + 1) + '/' + missing.length + ': ' + s.artist + ' - ' + s.title;

    try {
      var query = encodeURIComponent('track:' + s.title + ' artist:' + s.artist);
      var resp = await fetch('https://api.spotify.com/v1/search?q=' + query + '&type=track&limit=1', {
        headers: { 'Authorization': 'Bearer ' + spotifyToken }
      });

      if (resp.status === 429) {
        var retry = parseInt(resp.headers.get('Retry-After') || '2');
        await new Promise(function(r) { setTimeout(r, retry * 1000); });
        i--; continue;
      }

      if (resp.ok) {
        var data = await resp.json();
        if (data.tracks && data.tracks.items && data.tracks.items.length > 0) {
          var idx = songs.indexOf(s);
          if (idx >= 0) {
            songs[idx].spotifyId = data.tracks.items[0].id;
            found++;
          }
        }
      }
    } catch (e) {}

    await new Promise(function(r) { setTimeout(r, 100); });
  }

  saveSongsToStorage();
  renderSongList();
  statusEl.textContent = 'Done! Found Spotify IDs for ' + found + '/' + missing.length + ' songs.';
  spotifyToken = null;
}

// ==================== GAME BOARD ====================
var gameState = {
  active: false,
  players: [
    { name: 'Player 1', cards: [] },
    { name: 'Player 2', cards: [] }
  ],
  currentPlayer: 0,
  currentSong: null,
  discardPile: [],
  phase: 'listening', // listening, placing, revealing, checking
  winCount: 10,
  usedSongIds: []
};

function showGameSetup() {
  document.getElementById('victory-overlay').classList.add('hidden');
  document.getElementById('setup-p1-name').value = gameState.players[0].name || 'Player 1';
  document.getElementById('setup-p2-name').value = gameState.players[1].name || 'Player 2';
  document.getElementById('game-setup-modal').classList.remove('hidden');
}

function closeGameSetup() {
  document.getElementById('game-setup-modal').classList.add('hidden');
}

function startGame() {
  var p1 = document.getElementById('setup-p1-name').value.trim() || 'Player 1';
  var p2 = document.getElementById('setup-p2-name').value.trim() || 'Player 2';
  var winCount = parseInt(document.getElementById('setup-win-count').value) || 10;

  gameState = {
    active: true,
    players: [
      { name: p1, cards: [] },
      { name: p2, cards: [] }
    ],
    currentPlayer: 0,
    currentSong: null,
    discardPile: [],
    phase: 'listening',
    winCount: winCount,
    usedSongIds: []
  };

  closeGameSetup();
  document.getElementById('victory-overlay').classList.add('hidden');

  // Hide bottom nav during game
  document.querySelector('.nav').style.display = 'none';

  // Show game board screen
  document.querySelectorAll('.screen').forEach(function(s) { s.classList.remove('active'); });
  document.getElementById('game-board').classList.add('active');

  renderGameBoard();
  gamePlayNext();
}

function quitGame() {
  gameState.active = false;
  document.getElementById('victory-overlay').classList.add('hidden');
  document.querySelector('.nav').style.display = '';

  // Pause playback
  if (sdkPlayer && sdkIsPlaying) {
    sdkPlayer.pause();
  }

  showScreen('home');
}

function getGameSongPool() {
  var pool;
  if (sessionPlaylist && sessionPlaylist.tracks.length > 0) {
    pool = sessionPlaylist.tracks;
  } else {
    var activeCats = getActiveCategories();
    pool = activeCats.length > 0
      ? songs.filter(function(s) { return activeCats.includes(s.category); })
      : songs;
  }
  // Filter out already-used songs
  return pool.filter(function(s) {
    var id = s.spotifyId || (s.artist + '|' + s.title);
    return gameState.usedSongIds.indexOf(id) === -1;
  });
}

async function gamePlayNext() {
  var pool = getGameSongPool();
  if (pool.length === 0) {
    // Reset used songs if pool exhausted
    gameState.usedSongIds = [];
    pool = getGameSongPool();
  }
  if (pool.length === 0) {
    setGameStatus('No songs available!', '');
    return;
  }

  var song = pool[Math.floor(Math.random() * pool.length)];
  var songId = song.spotifyId || (song.artist + '|' + song.title);
  gameState.usedSongIds.push(songId);
  gameState.currentSong = song;
  gameState.phase = 'listening';

  setGameStatus('Listen & guess!', '');
  renderGameBoard();

  // Play via SDK
  activePlayingSong = song;
  popoutPlayingSong = null;
  updateNowPlayingBar(song, true);
  if (sdkReady && sdkDeviceId) {
    resetProgressBars();
    clearPlayerError();
    var success = await startSDKPlayback(song);
    if (!success) {
      setGameStatus('Playback failed - skip?', 'wrong');
    }
  } else {
    setGameStatus('Connect Spotify first!', 'wrong');
  }
}

function setGameStatus(text, cls) {
  var el = document.getElementById('game-status-text');
  el.textContent = text;
  el.className = 'game-topbar-status' + (cls ? ' ' + cls : '');
}

function renderGameBoard() {
  var body = document.getElementById('game-body');
  body.textContent = '';

  for (var p = 0; p < gameState.players.length; p++) {
    var player = gameState.players[p];
    var isActive = (p === gameState.currentPlayer && gameState.phase !== 'done');

    var row = document.createElement('div');
    row.className = 'player-row player-' + p + (isActive ? ' active-turn' : '');

    // Header
    var header = document.createElement('div');
    header.className = 'player-row-header';
    var nameEl = document.createElement('span');
    nameEl.className = 'player-row-name';
    nameEl.textContent = player.name;
    if (isActive) {
      var star = document.createElement('span');
      star.className = 'star';
      star.textContent = '\u2605';
      nameEl.appendChild(star);
    }
    header.appendChild(nameEl);
    var scoreEl = document.createElement('span');
    scoreEl.className = 'player-row-score';
    scoreEl.textContent = player.cards.length + '/' + gameState.winCount;
    header.appendChild(scoreEl);
    row.appendChild(header);

    // Card row
    var cardRow = document.createElement('div');
    cardRow.className = 'card-row';

    if (isActive) {
      // Show placement slots interspersed with cards
      if (player.cards.length === 0) {
        var emptySlot = createPlacementSlot(p, 0, true);
        cardRow.appendChild(emptySlot);
      } else {
        // Slot before first card
        cardRow.appendChild(createPlacementSlot(p, 0, false));
        for (var c = 0; c < player.cards.length; c++) {
          cardRow.appendChild(createGameCard(player.cards[c], p));
          cardRow.appendChild(createPlacementSlot(p, c + 1, false));
        }
      }
    } else {
      // Non-active player: just show cards
      if (player.cards.length === 0) {
        var emptyMsg = document.createElement('div');
        emptyMsg.style.cssText = 'color:var(--text-dim);font-size:13px;padding:10px;';
        emptyMsg.textContent = 'No cards yet';
        cardRow.appendChild(emptyMsg);
      } else {
        for (var c2 = 0; c2 < player.cards.length; c2++) {
          cardRow.appendChild(createGameCard(player.cards[c2], p));
        }
      }
    }

    row.appendChild(cardRow);
    body.appendChild(row);
  }

  // Piles container (deck + discard side by side)
  var pilesContainer = document.createElement('div');
  pilesContainer.className = 'game-piles';

  // --- Card Deck ---
  var deck = document.createElement('div');
  deck.className = 'deck-visual';
  var deckCard = document.createElement('div');
  // During waiting, show next player's color on deck (the card being drawn is theirs)
  var deckPlayerIdx = gameState.phase === 'waiting'
    ? (gameState.currentPlayer + 1) % gameState.players.length
    : gameState.currentPlayer;
  deckCard.className = 'deck-card deck-p' + deckPlayerIdx;
  // Music note icon (face down)
  deckCard.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 3v10.55A4 4 0 1014 17V7h4V3h-6z"/></svg>';
  // Show remaining song count
  var songPool = getGameSongPool();
  var remaining = songPool.length;
  if (remaining > 0) {
    var deckCount = document.createElement('div');
    deckCount.className = 'deck-count';
    deckCount.textContent = remaining;
    deckCard.appendChild(deckCount);
  }
  // During waiting phase: click deck to advance to next turn
  // Otherwise: click to play/resume current song
  if (gameState.phase === 'waiting') {
    deckCard.classList.add('deck-next-turn');
    deckCard.addEventListener('click', function() {
      gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.players.length;
      gamePlayNext();
    });
  } else {
    deckCard.addEventListener('click', function() {
      if (gameState.currentSong) {
        popoutPlayingSong = null;
        activePlayingSong = gameState.currentSong;
        startSDKPlayback(gameState.currentSong);
        updateNowPlayingBar(gameState.currentSong, true);
      }
    });
  }
  deck.appendChild(deckCard);
  var deckLabel = document.createElement('div');
  deckLabel.className = 'deck-label';
  deckLabel.textContent = gameState.phase === 'waiting' ? 'Next turn' : 'Deck';
  deck.appendChild(deckLabel);
  pilesContainer.appendChild(deck);

  // --- Discard Pile ---
  var pile = document.createElement('div');
  pile.className = 'discard-pile-visual';
  pile.addEventListener('click', function() { showDiscardModal(); });

  if (gameState.discardPile.length === 0) {
    pile.classList.add('discard-pile-empty');
    var emptyCard = document.createElement('div');
    emptyCard.className = 'discard-pile-card-empty';
    emptyCard.textContent = 'Empty';
    pile.appendChild(emptyCard);
  } else {
    var last = gameState.discardPile[gameState.discardPile.length - 1];
    var topCard = document.createElement('div');
    topCard.className = 'discard-pile-card card-p' + last.playerIndex;

    var tcYear = document.createElement('div');
    tcYear.className = 'game-card-year';
    tcYear.textContent = last.song.year || '????';
    topCard.appendChild(tcYear);

    var tcArtist = document.createElement('div');
    tcArtist.className = 'game-card-artist';
    tcArtist.textContent = last.song.artist;
    topCard.appendChild(tcArtist);

    var tcTitle = document.createElement('div');
    tcTitle.className = 'game-card-title';
    tcTitle.textContent = last.song.title;
    topCard.appendChild(tcTitle);

    if (gameState.discardPile.length > 1) {
      var countBadge = document.createElement('div');
      countBadge.className = 'discard-pile-count';
      countBadge.textContent = gameState.discardPile.length;
      topCard.appendChild(countBadge);
    }

    pile.appendChild(topCard);
  }

  var pileLabel = document.createElement('div');
  pileLabel.className = 'discard-pile-label';
  pileLabel.textContent = 'Discard';
  pile.appendChild(pileLabel);
  pilesContainer.appendChild(pile);

  body.appendChild(pilesContainer);
}

function createGameCard(cardData, playerIdx) {
  var card = document.createElement('div');
  card.className = 'game-card card-p' + playerIdx;

  var year = document.createElement('div');
  year.className = 'game-card-year';
  year.textContent = cardData.song.year || '????';
  card.appendChild(year);

  var artist = document.createElement('div');
  artist.className = 'game-card-artist';
  artist.textContent = cardData.song.artist;
  card.appendChild(artist);

  var title = document.createElement('div');
  title.className = 'game-card-title';
  title.textContent = cardData.song.title;
  card.appendChild(title);

  card.addEventListener('click', function() {
    showCardPopout(cardData.song, playerIdx);
  });

  return card;
}

// Card pop-out overlay with play/pause button
var popoutPlayingSong = null; // track which song the popout started
var activePlayingSong = null; // track what's actually playing right now

function updateNowPlayingBar(song, isGameSong) {
  var container = document.getElementById('game-nowplaying');
  var yearEl = document.getElementById('game-nowplaying-year');
  var artistEl = document.getElementById('game-nowplaying-artist');
  var titleEl = document.getElementById('game-nowplaying-title');
  if (!container || !artistEl || !titleEl) return;

  if (!song) {
    if (yearEl) yearEl.textContent = '';
    artistEl.textContent = '';
    titleEl.textContent = '';
    container.className = 'game-topbar-nowplaying obfuscated';
    return;
  }

  if (yearEl) yearEl.textContent = song.year || '????';
  artistEl.textContent = song.artist || '';
  titleEl.textContent = song.title || '';
  container.className = 'game-topbar-nowplaying' + (isGameSong ? ' obfuscated' : '');
}

function showCardPopout(song, playerIdx) {
  // Remove any existing popout
  closeCardPopout();

  var overlay = document.createElement('div');
  overlay.className = 'card-popout-overlay';
  overlay.id = 'card-popout-overlay';

  var popout = document.createElement('div');
  popout.className = 'card-popout popout-p' + playerIdx;

  // Album art
  var artEl = document.createElement('img');
  artEl.className = 'card-popout-art';
  artEl.alt = '';
  artEl.style.display = 'none';
  if (song.albumArt) {
    artEl.src = song.albumArt;
    artEl.style.display = 'block';
  } else if (sdkToken && song.artist && song.title) {
    // Fetch album art on-demand
    searchSpotifyId(song).then(function() {
      if (song.albumArt) {
        artEl.src = song.albumArt;
        artEl.style.display = 'block';
      }
    });
  }
  popout.appendChild(artEl);

  var yearEl = document.createElement('div');
  yearEl.className = 'card-popout-year';
  yearEl.textContent = song.year || '????';
  popout.appendChild(yearEl);

  var artistEl = document.createElement('div');
  artistEl.className = 'card-popout-artist';
  artistEl.textContent = song.artist;
  popout.appendChild(artistEl);

  var titleEl = document.createElement('div');
  titleEl.className = 'card-popout-title';
  titleEl.textContent = song.title;
  popout.appendChild(titleEl);

  // Play/pause button (white circle, black icon  Spotify style)
  var playBtn = document.createElement('button');
  playBtn.className = 'card-popout-play';
  playBtn.id = 'popout-play-btn';
  var isThisSongPlaying = popoutPlayingSong === song && sdkIsPlaying;
  playBtn.innerHTML = isThisSongPlaying
    ? '<svg viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>'
    : '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
  playBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    if (popoutPlayingSong === song && sdkIsPlaying) {
      if (sdkPlayer) sdkPlayer.pause();
      playBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
    } else {
      popoutPlayingSong = song;
      activePlayingSong = song;
      startSDKPlayback(song);
      var isGameSong = gameState.active && gameState.currentSong === song;
      updateNowPlayingBar(song, isGameSong);
      playBtn.innerHTML = '<svg viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>';
    }
  });
  popout.appendChild(playBtn);

  // "Back to current song" button  only show during an active game with a current song
  if (gameState.active && gameState.currentSong && gameState.currentSong !== song) {
    var backBtn = document.createElement('button');
    backBtn.className = 'btn btn-sm btn-outline';
    backBtn.style.cssText = 'margin-top:14px;display:block;width:100%;';
    backBtn.textContent = 'Back to current song';
    backBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      popoutPlayingSong = null;
      activePlayingSong = gameState.currentSong;
      startSDKPlayback(gameState.currentSong);
      updateNowPlayingBar(gameState.currentSong, true);
      closeCardPopout();
    });
    popout.appendChild(backBtn);
  }

  overlay.appendChild(popout);

  // Click outside to close
  overlay.addEventListener('click', function(e) {
    if (e.target === overlay) {
      closeCardPopout();
    }
  });

  document.body.appendChild(overlay);
}

function closeCardPopout() {
  var existing = document.getElementById('card-popout-overlay');
  if (existing) existing.remove();
}

function createPlacementSlot(playerIdx, position, isEmpty) {
  var slot = document.createElement('div');
  slot.className = 'placement-slot slot-p' + playerIdx + (isEmpty ? ' empty-row' : '');
  slot.textContent = isEmpty ? '+ Place here' : '+';
  slot.addEventListener('click', function() {
    placeCard(playerIdx, position);
  });
  return slot;
}

async function placeCard(playerIdx, position) {
  if (gameState.phase !== 'listening') return;
  if (playerIdx !== gameState.currentPlayer) return;
  if (!gameState.currentSong) return;

  gameState.phase = 'placing';
  var song = gameState.currentSong;
  var player = gameState.players[playerIdx];
  var cardData = { song: song };

  // Capture the deck card position before re-render
  var deckCardEl = document.querySelector('.deck-card');
  var deckRect = deckCardEl ? deckCardEl.getBoundingClientRect() : null;

  // Animate the deck: transition current card out, reveal next player's color underneath
  if (deckCardEl) {
    var nextPlayerIdx = (gameState.currentPlayer + 1) % gameState.players.length;
    deckCardEl.classList.add('dealing');
    // After a brief delay, swap the deck card color to next player
    await sleep(200);
    deckCardEl.classList.remove('deck-p' + gameState.currentPlayer);
    deckCardEl.classList.add('deck-p' + nextPlayerIdx);
    deckCardEl.classList.remove('dealing');
    deckCardEl.style.opacity = '1';
    deckCardEl.style.transform = '';
  }

  // Insert card into data model and re-render
  player.cards.splice(position, 0, cardData);
  renderGameBoard();
  await sleep(50);

  // Find the newly placed card in the DOM
  var rows = document.querySelectorAll('.player-row');
  var activeRow = rows[playerIdx];
  if (!activeRow) { checkPlacement(playerIdx, position); return; }
  var cardEls = activeRow.querySelectorAll('.game-card');
  var placedCard = cardEls[position];

  if (placedCard && deckRect) {
    var targetRect = placedCard.getBoundingClientRect();

    // Create a flying card clone at the deck's position
    var flyCard = document.createElement('div');
    flyCard.className = 'game-card card-p' + playerIdx;
    flyCard.style.cssText = 'position:fixed;z-index:300;width:' + deckRect.width + 'px;height:' + deckRect.height + 'px;'
      + 'left:' + deckRect.left + 'px;top:' + deckRect.top + 'px;'
      + 'transition:left 0.45s ease-out,top 0.45s ease-out,width 0.45s ease-out,height 0.45s ease-out,transform 0.3s ease-out 0.25s;'
      + 'pointer-events:none;backface-visibility:hidden;display:flex;align-items:center;justify-content:center;';
    // Face-down: show music note
    flyCard.innerHTML = '<svg viewBox="0 0 24 24" style="width:32px;height:32px;opacity:0.4;fill:var(--p' + playerIdx + ')"><path d="M12 3v10.55A4 4 0 1014 17V7h4V3h-6z"/></svg>';
    document.body.appendChild(flyCard);

    // Hide the actual card during flight
    placedCard.style.visibility = 'hidden';

    // Trigger flight
    await sleep(20);
    flyCard.style.left = targetRect.left + 'px';
    flyCard.style.top = targetRect.top + 'px';
    flyCard.style.width = targetRect.width + 'px';
    flyCard.style.height = targetRect.height + 'px';

    // Wait for flight to arrive
    await sleep(460);

    // Flip: rotate to 90deg (hide face-down)
    flyCard.style.transition = 'transform 0.15s ease-in';
    flyCard.style.transform = 'rotateY(90deg)';
    await sleep(160);

    // Swap to revealed content and flip back
    flyCard.remove();
    placedCard.style.visibility = '';
    placedCard.style.transform = 'rotateY(90deg)';
    placedCard.style.transition = 'transform 0.2s ease-out';
    await sleep(20);
    placedCard.style.transform = 'rotateY(0deg)';
    await sleep(220);
    placedCard.style.transform = '';
    placedCard.style.transition = '';
  } else if (placedCard) {
    // Fallback: simple flip if no deck rect
    placedCard.style.transform = 'rotateY(90deg)';
    placedCard.style.transition = 'transform 0.3s ease-out';
    await sleep(50);
    placedCard.style.transform = 'rotateY(0deg)';
    await sleep(350);
    placedCard.style.transform = '';
    placedCard.style.transition = '';
  }

  gameState.phase = 'revealing';
  setGameStatus('Placed: ' + song.artist + ' - ' + (song.year || '????'), '');
  // Un-blur now-playing since the song is revealed
  updateNowPlayingBar(song, false);

  await sleep(200);
  checkPlacement(playerIdx, position);
}

async function checkPlacement(playerIdx, position) {
  gameState.phase = 'checking';
  var player = gameState.players[playerIdx];
  var cardData = player.cards[position];
  var year = cardData.song.year || 0;

  var leftOk = true, rightOk = true;
  if (position > 0) {
    var leftYear = player.cards[position - 1].song.year || 0;
    if (year < leftYear) leftOk = false;
  }
  if (position < player.cards.length - 1) {
    var rightYear = player.cards[position + 1].song.year || 0;
    if (year > rightYear) rightOk = false;
  }

  var correct = leftOk && rightOk;

  // Find placed card element for animation
  var rows = document.querySelectorAll('.player-row');
  var activeRow = rows[playerIdx];
  var cardEls = activeRow ? activeRow.querySelectorAll('.game-card') : [];
  var placedCard = cardEls[position];

  if (correct) {
    setGameStatus('Correct! ' + cardData.song.artist + ' (' + (cardData.song.year || '????') + ')', 'correct');
    if (placedCard) {
      placedCard.classList.add('correct-glow');
    }
    await sleep(1200);

    // Check win condition
    if (player.cards.length >= gameState.winCount) {
      showVictory(playerIdx);
      return;
    }
  } else {
    setGameStatus('Wrong! ' + cardData.song.artist + ' (' + (cardData.song.year || '????') + ')', 'wrong');
    if (placedCard) {
      placedCard.classList.add('wrong-shake');
      await sleep(500);
      placedCard.classList.remove('wrong-shake');
      placedCard.classList.add('wrong-slide');
      await sleep(400);
    }
    // Remove card and add to discard
    player.cards.splice(position, 1);
    gameState.discardPile.push({ song: cardData.song, playerIndex: playerIdx });
    renderGameBoard();
    await sleep(400);
  }

  // Stay on current player's turn until deck is clicked
  gameState.phase = 'waiting';
  renderGameBoard();
  setGameStatus('', '');
}

function showVictory(playerIdx) {
  var player = gameState.players[playerIdx];
  document.getElementById('victory-title').textContent = player.name + ' Wins!';
  document.getElementById('victory-subtitle').textContent = 'With ' + player.cards.length + ' cards';
  var victoryCard = document.querySelector('.victory-card');
  victoryCard.classList.remove('victory-p0', 'victory-p1');
  victoryCard.classList.add('victory-p' + playerIdx);
  document.getElementById('victory-overlay').classList.remove('hidden');
  gameState.phase = 'done';

  if (sdkPlayer && sdkIsPlaying) {
    sdkPlayer.pause();
  }
}

function showDiscardModal() {
  var list = document.getElementById('discard-list');
  list.textContent = '';

  if (gameState.discardPile.length === 0) {
    var empty = document.createElement('div');
    empty.style.cssText = 'text-align:center;color:var(--text-dim);padding:20px;';
    empty.textContent = 'No discards yet';
    list.appendChild(empty);
  } else {
    for (var i = gameState.discardPile.length - 1; i >= 0; i--) {
      var d = gameState.discardPile[i];
      var item = document.createElement('div');
      item.className = 'discard-item discard-p' + d.playerIndex;

      var yearEl = document.createElement('div');
      yearEl.className = 'discard-item-year';
      yearEl.textContent = d.song.year || '????';
      item.appendChild(yearEl);

      var info = document.createElement('div');
      info.className = 'discard-item-info';

      var artistEl = document.createElement('div');
      artistEl.className = 'discard-item-artist';
      artistEl.textContent = d.song.artist;
      info.appendChild(artistEl);

      var titleEl = document.createElement('div');
      titleEl.className = 'discard-item-title';
      titleEl.textContent = d.song.title;
      info.appendChild(titleEl);

      var playerEl = document.createElement('div');
      playerEl.className = 'discard-item-player';
      playerEl.textContent = 'Discarded by ' + gameState.players[d.playerIndex].name;
      info.appendChild(playerEl);

      item.appendChild(info);

      // Click to show popout with play button
      (function(song, pIdx) {
        item.addEventListener('click', function() {
          showCardPopout(song, pIdx);
        });
      })(d.song, d.playerIndex);

      list.appendChild(item);
    }
  }

  document.getElementById('discard-modal').classList.remove('hidden');
}

function closeDiscardModal() {
  document.getElementById('discard-modal').classList.add('hidden');
}

function sleep(ms) {
  return new Promise(function(resolve) { setTimeout(resolve, ms); });
}

// Override showScreen to handle game board properly
var _originalShowScreen = showScreen;
showScreen = function(id) {
  if (gameState.active && id !== 'game-board') {
    // If quitting game, restore nav
    gameState.active = false;
    document.querySelector('.nav').style.display = '';
  }
  _originalShowScreen(id);
};

// Update game progress bar along with others
var _origUpdateProgressBars = updateProgressBars;
updateProgressBars = function() {
  _origUpdateProgressBars();
  var pct = sdkDuration > 0 ? (sdkCurrentPosition / sdkDuration * 100) : 0;
  var gameBar = document.getElementById('game-progress-bar');
  if (gameBar) gameBar.style.width = pct + '%';
};

// Update game play/pause button along with others
var _origUpdatePlayPause = updatePlayPauseButtons;
updatePlayPauseButtons = function() {
  _origUpdatePlayPause();
  var gameBtn = document.getElementById('game-play-btn');
  if (gameBtn) {
    gameBtn.innerHTML = sdkIsPlaying ? PAUSE_SVG : PLAY_SVG;
  }
};

// ==================== SERVICE WORKER ====================
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(function() {});
}

// ==================== STARTUP ====================
init();
</script>
</body>
</html>
